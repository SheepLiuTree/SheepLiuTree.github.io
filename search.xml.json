[{"title":"兔年元旦","url":"/2022/12/31/洋芋加糖/2023-01-01/","content":"<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/鱼酷合照.jpg\" alt=\"今年最后的合照\" width=\"200\"  align=\"bottom\" />  \n\n　　今年最后的合照我居然没有原图呀宝贝❤️  \n　　宝贝，虎年过去了，迎来了我们的本命年，兔兔🐇年了，宝贝新年快乐哦❤️  \n　　这一年过的好快呀，尤其是下半年呀，感觉不到的呢就过去了，和宝宝在一起时间就是过的非常快呢❤️  \n　　2022年对宝贝来说是的非常重要的一年呢，这一年在宝宝身上发生了好多的事情，年初宝贝在紧张的心情下取得了优异的成绩\n  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/激动1.png\" alt=\"激动\" width=\"150\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/考研成绩.png\" alt=\"宝贝优秀的成绩\" width=\"200\"  align=\"bottom\" />\n　　考了好成绩的宝贝也带着胜利的喜讯来青岛度假，来陪我了，我们终于一起喂了海鸥，去了湛山寺祈福，去了大学路打卡\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/举杯庆祝.jpg\" alt=\"举杯庆祝\" width=\"200\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/七个葫芦娃.png\" alt=\"偶遇兄弟们\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/宝贝喂海鸥.png\" alt=\"喂海鸥\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/大学路.png\" alt=\"宝宝真美\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-1.png\" alt=\"杨大胆欺负宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-2.png\" alt=\"我拍的真好看\" width=\"400\"  align=\"bottom\" />\n　　然后就又开始了漫长的，为期6个月的网恋，在这6个月里宝宝还去做了辛勤的园丁，成为了熏老师  \n　　随之到了9月，宝宝该开学了，宝宝要来青岛了，终于能和宝宝长时间的在一起了\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-3.png\" alt=\"好看的天和幸福的我们\" width=\"400\"  align=\"bottom\" />\n　　宝宝刚开学就被囚禁了，只能隔着栏杆探监宝贝，铁窗泪啊😭\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-4.png\" alt=\"短短的探监\" width=\"400\"  align=\"bottom\" />\n　　我们的第一次约会，宝宝迟到了好久，但是，宝宝超美！！！😍\n　　但是。。。不得不说我的拍照技术属实有点烂，我居然选不出照片来😭\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-5.png\" alt=\"超美的宝宝\" height=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-6.png\" alt=\"宝宝耳钉真好看\" height=\"400\"  align=\"bottom\" />\n　　宝宝嫌俺胡子扎人，给俺买了刮胡刀❤️\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-7.png\" alt=\"用宝宝给买的刮胡刀剃的胡子真干净\" height=\"400\"  align=\"bottom\" />\n　　和宝宝约会，约会，又约会，要和宝宝天天约会，呕吼😍  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-8.png\" alt=\"正在摆造型的宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-9.png\" alt=\"有好看丸子头的宝宝\" width=\"200\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-10.png\" alt=\"为数不多的拍的好看的照片\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-11.png\" alt=\"第二为数不多的拍的好看的照片\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-12.png\" alt=\"两张占满屏幕的大脸\" width=\"400\"  align=\"bottom\" />\n　　第二次探监😭  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-13.png\" alt=\"爱吃巧克力的宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-14.png\" alt=\"呲牙喜的俩人\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-15.png\" alt=\"铁窗泪-第二部\" width=\"400\"  align=\"bottom\" />\n　　宝宝生日要到了🎂\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-21.png\" alt=\"送给宝宝的油条花\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-16.png\" alt=\"捡叶叶\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-17.png\" alt=\"蝴蝶蝶\" width=\"400\"  align=\"bottom\" />\n　　可是没有成品照片唉  \n\n　　宝宝生日快乐🎂\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-18.png\" alt=\"许愿的宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-19.png\" alt=\"好看的宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-20.png\" alt=\"仙女宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-22.png\" alt=\"宝宝的花花和我\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-23.png\" alt=\"宝宝的簪子\" width=\"400\"  align=\"bottom\" />\n　　接着约会约会🥰\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-24.png\" alt=\"宝宝带我吃鸡爪\" width=\"400\"  align=\"bottom\" />  \n　　宝宝放假了  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-25.png\" alt=\"宝宝陪我上班\" width=\"400\"  align=\"bottom\" />  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-26.png\" alt=\"流氓宝宝\" width=\"400\"  align=\"bottom\" /> \n　　呼应一下开头\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-27.png\" alt=\"最后的鱼\" width=\"400\"  align=\"bottom\" /> \n　　然后宝宝就回家了，我们又分开了，想宝宝了，亲你一口，你没回应，但我还是想你爱你哦。  \n\n　　宝宝，我们的照片好少呀，记录一下还是挺好的呢，都是些美好的回忆呀❤️  \n\n　　宝宝，新的一年快乐，2016快乐，在这里还要向宝宝道歉，我们的2000天纪念日我忘记了，还请宝宝责罚😘  \n\n　　宝宝，新的一年我们还要好好的，我们还要出去玩，去约会，我还会找你约会，去做宝宝学习路上的绊脚石的，老婆我爱你，我爱你哦❤️❤️❤️","tags":["洋芋加糖"],"categories":["洋芋加糖"]},{"title":"74HC595-I/O口扩展芯片","url":"/2022/11/07/单片机/74HC595/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章引用资源：  \n>+ <font color=LightSeaGreen>电子发烧友-**ss**:</font>  https://www.elecfans.com/dianzichangshi/20171208598361.html\n>+ <font color=LightSeaGreen>**74HC595数据手册**:</font>https://www.nexperia.com/products/logic/i-o-expansion-logic/shift-registers/74HC595D.html\n\n{% endnote %}\n\n---\n## 74HC595简介\n　　74HC595是一个8位串行输入、平行输出的位移缓存器：平行输出为三态输出。在SCK的上升沿，单行数据由SDL输人到内部的8位位移缓存器，并由Q7‘输出，而平行输出则是在LCK的上升沿将在8位位移缓存器的数据存人到8位平行输出缓存器。当串行数据输人端OE的控制信号为低使能时，平行输出端的输出值等于平行输出缓存器所存储的值。而当OE为高电位，也就是输出关闭时，平行输出端会维持在高阻抗状态。\n## 74hc595引脚图及功能\n![74HC595引脚图](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/74HC595引脚图.png)\nSymbol|Pin|Description\n|:---:|:---:|:---:|\nQ0-Q7|15,1,2,3,4,5,6,7|8位数据并行输出口\nGND|8|接地\nQ7S|9|串行数据输出，级联时连接下一芯片串行输入(DS)\nMR|10|主复位(低电平有效)，将移位寄存器清零，通常接高电平\nSHCP|11|数据输入时钟线，上升沿时将串行数据右移一位\nSTCP|12|输出寄存器锁存时钟，上升沿时将串行数据移至输出寄存器\nOE|13|输出有效(低电平有效)，通常接低电平\nDS|14|串行数据输入，级联时接上一芯片串行数据输出(Q7S)\nVCC|16|电源\n## 真值表与时序图\n","tags":["单片机","芯片"],"categories":["单片机"]},{"title":"侧边组件实现打开关闭及调整","url":"/2022/08/03/侧边组件/侧边组件实现打开关闭及调整/","content":"`main.qml`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Window 2.14\nimport QtQuick.Controls 1.4\nimport QtQuick.Controls 2.15\n\nWindow {\n    id: mainwindow\n    x: Screen.width-mainwindowSizeW.value\n    y: mainwindowYPos.value\n    width: mainwindowSizeW.value\n    height: mainwindowSizeH.value\n    visible: true\n    flags: Qt.FramelessWindowHint|Qt.Window|Qt.WindowStaysOnTopHint\n    color: \"transparent\"\n    title: qsTr(\"Hello World\")\n\n    Item{\n        anchors.fill: parent\n\n        Rectangle{\n            id:rect1\n            anchors.fill: parent\n            radius: mainwindowRadius.value\n            color: \"red\"        \n        }\n        MouseArea{\n            anchors.fill: rect1\n            hoverEnabled: true\n            onEntered: mywindow.visible = true\n        }\n        Component.onCompleted: {\n\n        }\n        }\n\n    MyWindow{\n        id: setting\n        width: 640\n        height: 480\n        x: Screen.width/2-width/2\n        y: Screen.height/2-height/2\n\n\n        Grid{\n            columns: 2\n            verticalItemAlignment: Grid.AlignVCenter\n            horizontalItemAlignment: Grid.AlignLeft\n            columnSpacing:  100\n            Label{ text: \"触发条位置\" }\n            Slider {\n                id: mainwindowYPos\n                 from: 30\n                 value: Screen.height/2-mainwindowSizeH.value/2\n                 to: Screen.height-mainwindowSizeH.value-30\n             }\n            Label{ text: \"触发条宽度\" }\n            Slider {\n                id: mainwindowSizeW\n                 from: 1\n                 value: 15\n                 to: 30\n             }\n            Label{ text: \"触发条高度\" }\n            Slider {\n                id: mainwindowSizeH\n                 from: 50\n                 value: 125\n                 to: 200\n             }\n            Label{ text: \"触发条圆角\" }\n            Slider {\n                id: mainwindowRadius\n                 from: 1\n                 value: 0\n                 to: mainwindowSizeW.value/2\n             }\n            Label{ text: \"快捷窗口宽度\" }\n            Slider {\n                id: mywindowW\n                 from: 100\n                 value: 400\n                 to: 1000\n             }\n            Label{ text: \"快捷窗口高度\" }\n            Slider {\n                id: mywindowH\n                 from: 100\n                 value: Screen.height-50\n                 to: Screen.height-10\n             }\n            Label{ text: \"快捷窗口位置\" }\n            Slider {\n                id: mywindowX\n                 from: 100\n                 value: mainwindow.x-mywindowW.value-20\n                 to: Screen.width-mywindowW.value\n             }\n            Label{ text: \"快捷窗口圆角\" }\n            Slider {\n                id: mywindowRadius\n                 from: 1\n                 value: 30\n                 to: mywindowW.value/2\n             }\n        }\n    }\n    MyWindow{\n        id: mywindow\n        width: mywindowW.value\n        height: mywindowH.value\n        x: mywindowX.value\n        y: Screen.height/2-mywindowH.value/2-10\n        flags: Qt.FramelessWindowHint|Qt.Widget\n        color: \"transparent\"\n\n        Item{\n            anchors.fill: parent\n\n            Rectangle{\n                id:mainRect\n                anchors.fill: parent\n                color: \"blue\"\n                radius: mywindowRadius.value\n                MouseArea{\n                    anchors.fill: mainRect\n                    hoverEnabled: true\n                    onExited: mywindow.visible = false\n                }\n                Rectangle{\n                    id: settingButton\n                    anchors.right: mainRect.right\n                    anchors.top: mainRect.top\n                    anchors.margins: 10\n                    width: 50\n                    height: 50\n\n                    MouseArea{\n                        anchors.fill: settingButton\n                        onClicked: setting.visible = true\n                    }\n                }\n            }\n        }\n\n    }\n}\n```\n`MyWindow.qml`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Controls 1.4\nimport QtQuick.Window 2.14\n\nWindow {\n}\n\n```\n实现效果\n![侧边组件实现打开关闭及调整](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/侧边组件实现打开关闭及调整.gif)\n","tags":["Qt","QML","笔记","侧边组件"],"categories":["Qt"]},{"title":"QML学习笔记(九)","url":"/2022/08/02/QML/QML学习笔记(九)/","content":"## Setting\n### 一、描述\n>Settings类型提供持久的与平台无关的应用程序设置。  \n>注意:此类型是通过导入Qt.labs.settings模块提供的。实验室模块中的类型不保证在未来的版本中保持兼容。 \n> \n>用户通常希望应用程序能够跨会话记住它的设置(窗口大小和位置，选项等)。设置类型使您能够以最少的工作量保存和恢复此类应用程序设置。  \n>通过在Settings元素中声明属性来指定各个设置值。支持所有基本类型属性。推荐的方法是使用属性别名，以便以两种方式自动更新属性。下面的示例显示如何使用“设置”存储和恢复窗口的几何图形。  \n```QML\nimport QtQuick.Window 2.1\n import Qt.labs.settings 1.0\n\n Window {\n     id: window\n\n     width: 800\n     height: 600\n\n     Settings {\n         property alias x: window.x\n         property alias y: window.y\n         property alias width: window.width\n         property alias height: window.height\n     }\n }\n\n```\n>在应用程序第一次启动时，窗口获得指定为800x600的默认尺寸。注意，没有指定默认位置—我们让窗口管理器处理它。稍后，当窗口几何形状更改时，新值将自动存储到持久设置中。第二次运行的应用程序将从持久设置中获得初始值，使窗口恢复到以前的位置和大小。  \n>通过使用属性别名来实现完全声明式语法，代价是在别名属性的值发生更改时存储持久设置。普通属性可用于对存储持久设置进行更细粒度的控制。下面的例子演示了如何保存组件销毁的设置。  \n```QML\nimport QtQuick 2.1\n import Qt.labs.settings 1.0\n\n Item {\n     id: page\n\n     state: settings.state\n\n     states: [\n         State {\n             name: \"active\"\n             // ...\n         },\n         State {\n             name: \"inactive\"\n             // ...\n         }\n     ]\n\n     Settings {\n         id: settings\n         property string state: \"active\"\n     }\n\n     Component.onDestruction: {\n         settings.state = page.state\n     }\n }\n```\n>注意现在如何在持久设置属性中指定默认值，并将实际属性绑定到该设置，以便从持久设置获得初始值。\n\n### 二、应用识别符\n>通过提供应用程序名称、组织和域或指定fileName来标识特定于应用程序的设置。\n```QML\n #include <QGuiApplication>\n #include <QQmlApplicationEngine>\n\n int main(int argc, char *argv[])\n {\n     QGuiApplication app(argc, argv);\n     app.setOrganizationName(\"Some Company\");\n     app.setOrganizationDomain(\"somecompany.com\");\n     app.setApplicationName(\"Amazing Application\");\n\n     QQmlApplicationEngine engine(\"main.qml\");\n     return app.exec();\n }\n```\n> 这些通常在c++中main()的开头指定，但也可以通过以下属性在QML中控制:\n>+ Qt.application.name,\n>+ Qt.application.organization\n>+ Qt.application.domain。\n \n ### 三、类\n>通过类别属性指定类别名称，可以将应用程序设置划分为逻辑类别。使用逻辑分类不仅可以提供更清晰的设置结构，还可以防止设置键之间可能的冲突。  \n>如果需要多个类别，使用多个设置对象，每个对象都有自己的类别:\n```QML\nItem {\n     id: panel\n\n     visible: true\n\n     Settings {\n         category: \"OutputPanel\"\n         property alias visible: panel.visible\n         // ...\n     }\n\n     Settings {\n         category: \"General\"\n         property alias fontSize: fontSizeSpinBox.value\n         // ...\n     }\n }\n```\n>不用确保应用程序中的所有设置都有唯一的名称，设置可以划分为唯一的类别，然后这些类别可能包含使用其他类别中使用的相同名称的设置——而不会产生冲突。\n\n### 四、注意事项\n>当前的实现基于QSettings。这就增加了某些限制，例如缺少变更通知。使用一个设置实例写入设置值不会更新另一个设置实例中的值，即使它们引用同一类别中的相同设置。  \n>信息存储在Windows上的系统注册表中，存储在macOS上的XML首选项文件中。在其他Unix系统中，如果没有标准，则使用INI文本文件。更多细节请参阅QSettings文档。\n### 五、属性\n\n1. `category` : string\n>此属性保存设置类别的名称。  \n>类别可用于将相关设置分组在一起。\n\n2. `fileName` : string\n>此属性保存设置文件的路径。如果该文件不存在，则创建该文件。  \n这个属性是在Qt 5.12中引入的。\n\n### 六、方法\n\n1. setValue(string key, var value)\n>将设置键的值设置为value。如果该键已经存在，则覆盖之前的值。  \n该方法在Qt 5.12中被引入。\n\n2. sync()\n>将任何未保存的更改写入永久存储，并重新加载同时被另一个应用程序更改的任何设置。  \n这个函数会从QSettings的析构函数中自动调用，并由事件循环定期调用，所以您通常不需要自己调用它。\n\n3. var value(string key, var defaultValue)\n> 返回设置键的值。如果该设置不存在，则返回defaultValue。  \n该方法在Qt 5.12中被引入。","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(八)","url":"/2022/08/01/QML/QML学习笔记(八) /","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## 自定义QML组件\n\n新建QML文件-`TimerDateLabel.qml`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Controls 1.4\n\nLabel {\n    id:label\n    Timer {\n        interval: 500; running: true; repeat: true\n        onTriggered: label.text = Date().toString()\n    }\n}\n```\n在`main.qml`中调用`TimerDateLabel.qml`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Window 2.14\nimport QtQuick.Controls 1.4\n\nWindow {\n    width: 640\n    height: 480\n    visible: true\n    title: qsTr(\"Hello World\")\n\n    Item{\n        anchors.fill: parent\n\n        Column{\n            TimerDateLable{\n              color: \"red\"\n            }\n            TimerDateLable{\n              color: \"blue\n            }\n    }\n\n}\n}\n```\n![QML自定义组件](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/QML自定义组件.png)\n\n\n\n","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(七)","url":"/2022/08/01/QML/QML学习笔记(七) /","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## Timer\n### 一、描述\n计时器可以用来触发一次动作，也可以在给定的时间间隔内重复触发。  \n\n这是一个显示当前日期和时间的计时器，每500毫秒更新一次文本。它使用JavaScript Date对象来访问当前时间。\n```QML\n import QtQuick 2.0\n\n Item {\n     Timer {\n         interval: 500; running: true; repeat: true\n         onTriggered: time.text = Date().toString()\n     }\n\n     Text { id: time }\n }\n```\n![Timer](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Timer.png)  \nTimer类型与动画计时器同步。因为动画计时器通常设置为60fps，所以计时器的分辨率最多为16ms。  \n如果Timer正在运行，并且它的一个属性被更改，运行时间将被重置。例如，如果一个间隔为1000ms的Timer在启动后500ms改变了它的repeat属性，那么运行时间将被重置为0，并在1000ms后触发Timer。\n### 二、属性\n1. `interval` : int\n>设置触发器之间的间隔，以毫秒为单位。  \n>缺省值是1000毫秒。  \n\n2. `repeat` : bool\n>如果repeat为真，则计时器在指定的时间间隔内重复触发;否则，计时器将在指定的时间间隔触发一次，然后停止(即运行将被设置为`false`)。  \n>重复默认值为`false`。\n\n3. `running` : bool\n>如果设置为`true`，启动计时器;否则将停止定时器。对于非重复计时器，在计时器被触发后，运行设置为`false`。  \n>`Running`默认为`false`。\n\n4. triggeredOnStart : bool\n>当计时器启动时，第一个触发器通常是在指定的时间间隔过后。有时希望在计时器启动时立即触发;例如，建立一个初始状态。  \n>如果triggeredOnStart为true，则计时器在启动时立即触发，然后按指定的间隔触发。注意，如果repeat被设置为false，计时器会被触发两次;一次开始，一次在间歇。  \n>triggeredOnStart默认为false。\n\n### 三、信号\n1. triggered()\n>该信号在Timer超时时发出。  \n>注意:对应的处理程序是onTriggered。\n\n### 四、方法\n1. restart()\n>重新启动定时器  \n>如果Timer没有运行它将被启动，否则它将被停止，重置为初始状态并启动。在调用restart()之后，running属性将为true。\n\n2. start()\n>启动定时器  \n>如果计时器已经在运行，调用此方法将不起作用。在调用start()之后，running属性将为true。\n\n3. stop()\n>停止计时器  \n>如果计时器未运行，调用此方法将不起作用。在调用stop()之后，running属性将为false。\n\n\n\n\n\n","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(六11)","url":"/2022/07/28/QML/QML学习笔记(六)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## ApplicationWindow\n### 一、描述\nApplicationWindow是一个窗口，增加了方便的定位项目，如菜单栏，工具栏和状态栏，以平台独立的方式。\n![ApplicationWindow](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/ApplicationWindow.png)  \n注意:默认情况下，ApplicationWindow是不可见的。\n### 二、属性\n1. `contentItem` : ContentItem\n>该组保存内容项的大小限制。这是工具栏和状态栏之间的区域。当计算实际窗口的有效大小约束时，`ApplicationWindow`将使用这个作为输入。它拥有以下6个属性，用于描述最小、隐式和最大尺寸:  \n\n分组属性|描述\n|-|-|\ncontentItem.minimumWidth|内容项的最小宽度。\ncontentItem.minimumHeight|内容项的最小高度。\ncontentItem.implicitWidth|内容项的隐式宽度。\ncontentItem.implicitHeight|内容项的隐式高度。\ncontentItem.maximumWidth|内容项的最大宽度。\ncontentItem.maximumHeight|内容项的最大高度。\n\n2. `menuBar` : MenuBar\n>这个属性保存菜单栏。  \n>缺省情况下，不设置此值。  \n\n3. `statusBar` : Item\n>此属性保存状态栏Item。  \n>它可以设置为任何Item类型，但通常与StatusBar一起使用。  \n>缺省情况下，不设置此值。当您设置状态栏项时，它将自动锚定到应用程序窗口中。  \n\n4. `style` : Component\n>窗口的样式组件。  \n\n5. `toolBar` : Item\n>此属性保存工具栏项目。  \n>它可以设置为任何Item类型，但通常与ToolBar一起使用。  \n>缺省情况下，不设置此值。当您设置工具栏项时，它将自动锚定到应用程序窗口中。\n\n### 三、示例\n```QML\nimport QtQuick 2.14\nimport QtQuick.Controls 1.4\nimport QtQuick.Layouts 1.15\n\nApplicationWindow {\n    id : window\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n    \n    minimumWidth:200          //窗口宽度最大值\n    minimumHeight:200         //窗口高度最大值\n    maximumWidth:300          //窗口宽度最小值\n    maximumHeight:300         //窗口宽度最小值\n\n    menuBar: MenuBar {        //菜单栏\n        Menu {                //菜单\n            title: \"File\"     //菜单标题\n            MenuItem { text: \"Open...\" }  //子菜单\n            MenuItem { text: \"Close\" }    //子菜单\n        }    \n        Menu {\n            title: \"Edit\"\n            MenuItem { text: \"Cut\" }\n            MenuItem { text: \"Copy\" }\n            MenuItem { text: \"Paste\" }\n            }\n         }\n    statusBar: StatusBar {    //状态栏\n        RowLayout {           //排列\n            anchors.fill: parent\n            Label { text: \"Read Only\" }\n              }\n         }\n    toolBar:ToolBar {         //工具栏\n         RowLayout {\n             anchors.fill: parent\n             ToolButton {     //工具按钮\n                 text: \"one\"\n             }\n             ToolButton {\n                 text: \"two\"\n             }\n             ToolButton {\n                 text: \"there\"\n             }\n             Item { Layout.fillWidth: true }\n             CheckBox {       //多选按钮\n                 text: \"Enabled\"\n                 checked: true\n                 Layout.alignment: Qt.AlignRight\n             }\n             }\n         }\n    \n        Rectangle{          //正方形,填充在内容区\n            anchors.fill: parent\n            color: \"blue\"\n        }\n        \n        style:Component {   //风格化设置\n                 id: redSquare\n\n                 Rectangle {\n                     color: \"red\"\n                     width: 10\n                     height: 10\n                 }\n             }\n\n         Loader { sourceComponent: redSquare }    //加载具体实例\n         Loader { sourceComponent: redSquare; x: 20 }\n}\n```\n![ApplicationWindow示例](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/ApplicationWindow示例.png)\n## 附加信号及附加属性\n可以附加在其他元素上的属性和信号\n### 附加信号(Attached Signals)\n以 `destruction` 的附加信号为例\n1. complted()\n>在对象实例化后触发。一旦建立了完整的QML环境，这可以用于在启动时执行脚本代码  \n>onCompleted信号处理程序可以在任何对象上声明。未定义运行处理程序的顺序。  \n>注意:相应的处理程序是`completed.onCompleted:{  }\n`\n\n2. destruction()\n>当对象开始销毁时发出。这可用于撤消响应`completed()`信号所做的工作，或应用程序中的其他命令性代码。  \n>ondestroy信号处理程序可以在任何对象上声明。未定义运行处理程序的顺序。  \n>注意:对应的处理程序是 `completed.onDestruction:{  }`\n\n```QML\nWindow {\n    id : window\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n   Component.onCompleted:{\n       console.log(\"window 构造完成\")\n   }\n   Component.onDestruction:{\n       console.log(\"window 析构完成\")\n   }\n   Rectangle{\n       anchors.fill: parent\n       color: \"red\"\n\n       Component.onCompleted:{\n           console.log(\"Rectangle 构造完成\")\n       }\n       Component.onDestruction:{\n           console.log(\"Rectangle 析构完成\")\n       }\n   }\n}\n```\n![附加信号](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/附加信号.png)\n### 附加属性\n以 `ScrollBar` 附加属性为例\n1. void decrease()\n\n\n","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(五)","url":"/2022/07/25/QML/QML学习笔记(五)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## CheckBox\n### 一、描述\nCheckBox 提供了复选框按钮，可以打开（选中）或关闭（未选中）。复选框通常用于从一组选项中选择一个或多个选项。对于更大的选项集，例如列表中的选项，请考虑改用 `CheckDelegate`。\n\n默认只有选中和未选中状态,除此之外，还有第三种状态：部分选中。可以使用 `tristate` 属性启用部分选中状态。\n### 二、属性成员\n1. `checkState` : enumeration\n> 复选框的选中状态。\n>+ Qt.Unchecked：未选中。\n>+ Qt.PartiallyChecked：部分选中。仅在启用三态时使用。\n>+ Qt.Checked：已选中。\n\n1. `nextCheckState` : function\n> 此属性包含一个回调函数，每当用户通过触摸、鼠标或键盘交互切换复选框时，都会调用该函数以**确定下一个选中状态**。\n> \n> 默认情况下，普通复选框在 `Qt.Unchecked` 和 `Qt.Checked` 状态之间循环，三态复选框在 `Qt.Unchecked`、`Qt.PartiallyChecked` 和 `Qt.Checked` 状态之间循环。\n### 三、CheckBox示例\n```QML\nimport QtQuick\nimport QtQuick.Controls\n \nWindow {\n    width: 640\n    height: 480\n    visible: true\n    title: qsTr(\"Hello World\")\n \n    CheckBox {\n        id: control\n        text: qsTr(\"CheckBox\")\n        checked: true\n        hoverEnabled: false\n \n        indicator: Rectangle {\n            implicitWidth: 26\n            implicitHeight: 26\n            x: control.leftPadding\n            y: parent.height / 2 - height / 2\n            radius: 3\n            border.color: control.down ? \"#17a81a\" : \"#21be2b\"\n \n            Rectangle {\n                width: 14\n                height: 14\n                x: 6\n                y: 6\n                radius: 2\n                color: control.down ? \"#17a81a\" : \"#21be2b\"\n                visible: control.checked\n            }\n        }\n \n        contentItem: Text {\n            text: control.text\n            font: control.font\n            opacity: enabled ? 1.0 : 0.3\n            color: control.down ? \"#17a81a\" : \"#21be2b\"\n            verticalAlignment: Text.AlignVCenter\n            leftPadding: control.indicator.width + control.spacing\n        }\n    }\n}\n```\n![CheckBox示例](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/CheckBox示例.gif)\n## ComboBox\n### 一、描述\n组合框是一个组合按钮和弹出列表。它提供了一种以占用最少屏幕空间的方式向用户呈现选项列表的方法。\nComboBox是用数据模型填充的。数据模型通常是JavaScript数组、ListModel或整数，但也支持其他类型的数据模型。\n### 二、属性成员\n1. `acceptableInput` : bool\n> 此属性保存组合框是否在可编辑文本字段中包含可接受的文本。  \n> 如果已经设置了验证器，只有当验证器接受当前文本作为最终字符串(而不是中间字符串)时，该值才为true。  \n\n2. **[read-only]** `count` : int\n> 此属性保存组合框中的项数。\n\n3. `currentIndex` : int\n> 此属性保存组合框中当前项的索引。  \n> 当count为0时，默认值为-1，否则为0。\n4. **[read-only]** `currentText` : string\n>此属性保存组合框中当前项的文本。\n5. **[read-only]** `currentValue` : string\n>此属性保存组合框中当前项的值。\n6. `delegate` : Component\n>此属性保存一个委托，该委托在弹出的组合框中显示项。  \n>建议使用ItemDelegate(或任何其他AbstractButton派生)作为委托。这确保了交互按预期工作，并且弹出窗口将在适当的时候自动关闭。当使用其他类型作为委托时，必须手动关闭弹出窗口。\n7. `displayText` : string\n>此属性保存组合框按钮上显示的文本。  \n>默认情况下，显示文本显示当前所选内容。也就是说，它在当前项目的文本之后。但是，可以使用自定义值重写默认的显示文本。\n```QML\nComboBox {\n            currentIndex: 1\n            displayText: \"Size: \" + currentText\n            model: [\"S\", \"M\", \"L\"]\n        }\n```\n![ComboBox-displayText属性](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/ComboBox-displayText属性.png)   \n8. `down` : bool\n>该属性保存组合框按钮在视觉上是否向下。  \n>除非显式设置，否则该属性在按下或弹出时为真。可见是真的。若要返回默认值，请将此属性设置为undefined。\n9. `editText` : string\n>此属性将文本保存在可编辑组合框的文本字段中。\n10. `editable` : bool\n>此属性保存组合框是否可编辑。  \n>默认值为false。\n11. `flat` : bool\n>该属性保存组合框按钮是否为平面。  \n>\n>平面组合框按钮不会绘制背景，除非与之交互。与普通的组合框相比，扁平的组合框提供的外观让它们在UI的其他部分中不那么显眼。例如，当将组合框放置到工具栏中时，可能需要将组合框做成扁平的，以便它与工具按钮的扁平外观更好地匹配。 \n>\n>默认值为false。\n12. **[read-only]** `highlightedIndex` : int\n>此属性保存组合框弹出列表中突出显示项的索引。  \n>当一个高亮显示的项被激活时，弹出窗口关闭，currentIndex被设置为highlightedIndex，并且这个属性的值被重置为-1，因为不再有高亮显示的项。\n13. **[read-only]** `implicitIndicatorHeight` : real\n>此属性保存隐式指示符高度。  \n>值等于indicator ? indicator.implicitHeight : 0.  \n>这通常与implicitcontenttheight和implicitBackgroundHeight一起使用来计算implicitHeight。\n14. **[read-only]** `implicitIndicatorWidth` : real\n>此属性保存隐式指示符宽度。  \n>值等于indicator ? indicator.implicitWidth : 0.  \n>这通常与implicitContentWidth和implicitBackgroundWidth一起使用来计算implicitWidth。\n15. `indicator` : Item\n>此属性保存删除指示器项。\n16. **[read-only]** inputMethodComposing : bool\n>此属性保存可编辑组合框是否具有来自输入法的部分文本输入。  \n>在组合时，输入法可能依赖组合框中的鼠标或键事件来编辑或提交部分文本。此属性可用于确定何时禁用可能干扰输入法正确操作的事件处理程序。\n17. `inputMethodHints` : flags\n>为输入法提供有关组合框的预期内容以及应该如何操作的提示。  \n>The default value is Qt.ImhNoPredictiveText.  \n>该值是标志的按位组合，如果没有设置提示，则为Qt.ImhNone。  \n>改变行为的标志有:  \n>+ `imhhiddentext` -字符应该被隐藏，因为通常在输入密码时使用。  \n>+ `imhsensitivedata` -键入的文本不应该被活动输入法存储在任何持久存储，如预测性用户字典。  \n>+ `imhnoautouppercase` -输入法不应该试图在句子结束时自动切换到大写。  \n>+ `Qt.ImhPreferNumbers`—首选编号(但不是必需的)。\n>+ `Qt.ImhPreferNumbers`—首选编号(但不是必需的)。\n>+ `Qt.ImhPreferUppercase`—大写字母首选(但不是必需的)。\n>+ `Qt.Imhprefer`-小写-首选小写字母(但不是必需的)。\n>+ `Qt.Imhnopredictivetext` -在输入时不要使用预测文本(即字典查找)。\n>+ `Qt.Imhdate`—文本编辑器的作用是作为一个日期字段。\n>+ `Qt.ImhTime` -文本编辑器的作用是时间字段。    \n> 限制输入的标志(独占标志)有:\n>+ `Qt.ImhDigitsOnly` -只允许输入数字。\n>+ `Qt.ImhFormattedNumbersOnly` -只允许输入数字。这包括小数点和负号。\n>+ `Qt.ImhUppercaseOnly` -只允许大写字母输入。\n>+ `Qt.ImhLowercaseOnly `-只允许小写字母输入。\n>+ `Qt.ImhDialableCharactersOnly` -只允许使用适合电话拨号的字符。\n>+ `Qt.ImhEmailCharactersOnly` -只允许适用于电子邮件地址的字符。\n>+ `Qt.ImhUrlCharactersOnly` -只允许与url匹配的字符。  \n> 面具:\n>+ `Imhexclusiveinputmask——如果使用了任何独占标志，则此掩码生成非零。`\n18. `model` : model\n> 此属性保存为组合框提供数据的模型。\n```QML\nComboBox {\n     textRole: \"key\"\n     model: ListModel {\n         ListElement { key: \"First\"; value: 123 }\n         ListElement { key: \"Second\"; value: 456 }\n         ListElement { key: \"Third\"; value: 789 }\n     }\n }\n```\n19. `popup` : Popup\n> 此属性保存弹出窗口。  \n> 如果需要，可以手动打开或关闭弹出窗口:\n>+ onSpecialEvent: comboBox.popup.close()\n20. `pressed` : bool\n>该属性保存组合框按钮是否被物理按下。按钮可以通过触摸或按键事件来按下。\n21. `selectTextByMouse` : bool\n>此属性保存是否可以用鼠标选择可编辑组合框的文本字段。  \n>`默认值为false。`\n22. `textRole` : string\n>此属性保存用于填充组合框的模型角色。  \n>当模型有多个角色时，可以通过设置textRole来确定应该显示哪个角色。\n23. `validator` : Validator\n>此属性保存可编辑组合框的输入文本验证器。  \n>当设置验证器时，文本字段将只接受使文本属性处于中间状态的输入。只有当按下回车键或回车键时文本处于可接受状态时，才会发出可接受的信号。  \n>目前支持的验证器是IntValidator、DoubleValidator和RegExpValidator。下面是一个使用验证器的例子，它允许在文本字段中输入0到10之间的整数:\n```QML\n ComboBox {\n     model: 10\n     editable: true\n     validator: IntValidator {\n         top: 9\n         bottom: 0\n     }\n }\n```\n24. `valueRole` : string\n>此属性保存模型角色，用于存储与模型中每个项关联的值。\n### 信号函数\n1. void accepted()\n>当按下可编辑组合框上的Return或Enter键时，会发出此信号。  \n>您可以处理这个信号，以便将新输入的项添加到模型中，例如:\n```QML\n ComboBox {\n     editable: true\n     model: ListModel {\n         id: model\n         ListElement { text: \"Banana\" }\n         ListElement { text: \"Apple\" }\n         ListElement { text: \"Coconut\" }\n     }\n     onAccepted: {\n         if (find(editText) === -1)\n             model.append({text: editText})\n     }\n }\n```\n![ComboBox-Accepted信号](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/ComboBox-Accepted信号.png)\n\n>在发出信号之前，将进行检查，以确定该字符串是否存在于模型中。如果是，currentIndex将被设置为它的索引，currentText将被设置为字符串本身。  \n>在发出信号之后，如果第一次检查失败(也就是说，项目不存在)，将进行另一次检查，以查看项目是否由信号处理程序添加。如果是，则相应地更新currentIndex和currentText。否则，它们将分别被设置为-1和“”。  \n>注意:如果组合框上设置了验证器，则只有在输入处于可接受状态时才会发出信号。  \n>注意:对应的处理程序是onAccepted。  \n\n2. void activated(int index)\n>当索引项被用户激活时，会发出此信号。  \n>当一个项目被选中时，弹出窗口是打开的，它会被激活，导致弹出窗口关闭(currentIndex会改变)，或者当弹出窗口关闭时，通过键盘导航组合框，导致currentIndex改变。设置currentIndex属性为index。  \n>注意:对应的处理程序是onActivated。  \n\n3. void highlighted(int index)\n>当用户突出显示弹出列表中索引处的项时，会发出此信号。  \n>高亮显示的信号只在弹出窗口打开和项目高亮显示时发出，但不一定激活。  \n>注意:相应的处理程序是onhighlight。\n### 三、方法函数\n1. void decrementCurrentIndex()\n> 减少组合框的当前索引，或者如果弹出列表可见，则减少突出显示的索引。\n2. int find(string text, enumeration flags)\n>返回指定文本的索引，如果没有找到匹配，则返回-1。  \n>执行搜索的方式由指定的匹配标志定义。默认情况下，组合框执行区分大小写的精确匹配(Qt.MatchExactly)。所有其他匹配类型都不区分大小写，除非还指定了`qt.MatchCasesSensitive`标志。  \n\n|常数|描述|\n|-|-|\n|Qt.MatchExactly|搜索词完全匹配(默认)。\nQt.MatchRegExp|搜索词以正则表达式的形式匹配。\nQt.MatchWildcard|搜索词使用通配符进行匹配。\nQt.MatchFixedString|搜索词匹配为一个固定的字符串。\nQt.MatchStartsWith|搜索词与条目的开始部分匹配。\nQt.MatchEndsWidth|搜索词与条目的结尾匹配。\nQt.MatchContains|搜索项包含在项目中。\nQt.MatchCaseSensitive|搜索是区分大小写的。\n\n3. void incrementCurrentIndex()\n>增加组合框的当前索引，或者如果弹出列表可见，则增加突出显示的索引。\n\n4. int indexOfValue(object value)\n>返回指定值的索引，如果没有找到匹配，则返回-1。  \n>有关如何使用此方法的示例，请参阅组合框模型角色。\n\n5. void selectAll()\n>选择组合框的可编辑文本字段中的所有文本。\n\n6. string textAt(int index)\n>返回指定索引的文本，如果索引出界，则返回空字符串。","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(四)","url":"/2022/07/24/QML/QML学习笔记(四)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## Qt中的基本类型\n### 基本类型如下表\n|类型|含义|\n|:---:|:---|\n|bool|二进制true / false值|\n|double|带有小数点的数字，以双精度存储|\n|enumeration|命名的枚举值|\n|int|整数，如0、10或-20|\n|list|QML对象列表|\n|real|带小数点的数|\n|string|自由格式的文本字符串|\n|url|资源定位器|\n|var|通用的属性类型|\n### QML模块提供的部分基本类型\n|类型|含义|\n|:---:|:---|\n|color|颜色类型值|\n|date|时间类型值|\n|font|字体类型值|\n|point|值带有x和y属性|\n|rect|值与x, y，宽度和高度属性|\n|size|值，该值具有宽度和高度属性|\n## 基本类型变量的动态绑定\n```QML\nWindow {\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n    Item {\n        anchors.fill: parent\n        id:root\n\n        property int number: parent.width  //定义变量等与窗口宽度\n        onNumberChanged:{                  //窗口变化,变量改变,触发槽函数\n            console.log('number',number)\n        }\n    }\n}\n```\n## 别名\n```QML\nWindow {\n    id : window\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n    Item {\n        anchors.fill: parent\n        id:root\n\n        property alias windowWidth: window.width  //使用别名windowWidth代替window.width\n\n        Component.onCompleted: {\n            windowWidth=100       //使用windowWidth可以控制窗口宽度\n        }\n    }\n}\n```","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(三)","url":"/2022/07/21/QML/QML学习笔记(三)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## QML的布局\n　　元素是以其**父对象**的左上角为基点,分别向左和向下进行延伸,可使用 `x:` 及 `y:` 进行位置的定义  \n　　`Z: ` 是对堆叠顺序进行定义,数字越大越靠顶部\n```QML\nWindow {\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n    Rectangle {             //定义一个矩形\n        id: rect0           //定义ID\n        x: 50               //定义x位置,相对于Window\n        y: 30               //定义x位置,相对于Window\n        width:100           //定义宽度\n        height: 100         //定义高度\n        border.width: 2     //定义边框宽度\n\n        Rectangle{          //定义一个矩形\n            id:rect1        //定义ID\n            x: 0            //定义x位置,相对于rect0\n            y: 0            //定义y位置,相对于rect0\n            z: 1            //定义堆叠顺序\n            width: 40\n            height: 40\n            color: \"red\"    //定义颜色\n                 }\n        Rectangle{          //定义一个矩形\n            id:rect2        //定义ID\n            x: 20           //定义x位置,相对于rect0\n            y: 20           //定义x位置,相对于rect0\n            z: 0            //定义堆叠顺序\n            width: 40\n            height: 40\n            color: \"green\"  //定义颜色\n                }\n             }\n}\n```\n![QML的布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/QML的布局.png)\n## 动态表达式绑定\n　　当`B`对象属性调用了`A`对象的属性，那么当`A`的属性变化时，`B`的属性会自动随之变化\n```QML\nRectangle{\n    id:rect1\n    x: 0\n    y: 0\n    width: 40\n    height: 40\n    color: \"red\"\n        }\nRectangle{\n    id:rect2\n    x: rect1.x              //采用rect1的x值\n    y: rect1.y+rect1.height //紧贴rect1的下部\n    width: 40\n    height: 40\n    color: \"green\"\n}\n//鼠标区域\nMouseArea{\n    anchors.fill: rect1 //鼠标锚点\n    drag.target: rect1  //rect1跟随鼠标进行更新\n}\n```\n　　当鼠标移动`rect1`时,`rect2`会自动跟随`rect1`进行移动\n![动态表达式绑定](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/动态表达式绑定.png)\n## 锚点布局\n　　可视组件必须有`宽度` `高度` `x` `y`的值  \n　　如不设定`x` `y`的值,默认为`0`\n```QML\nRectangle{          //没设定x,y和锚点,默认在0,0位置\n    id:rect1\n    width: 40\n    height: 70\n    color: \"red\"\n        }\nRectangle{\n    id:rect2\n    width: 60\n    height: 40\n    color: \"green\"\n    //设置rect2的垂直中心锚点与rect1的垂直中心锚点对齐\n    anchors.verticalCenter: rect1.verticalCenter\n    anchors.left: rect1.right   //设置rect2的左边锚点与rect1的右边锚点对齐\n    anchors.leftMargin: 5       //设置rect2的左外边距5px\n        }\n\nItem {      //不可视元素,不设置默认也会自带一个\n    anchors.fill: parent //设置填充整个窗口\n\n    Rectangle{\n        id: rect3\n        width: 30\n        height: 30\n        color: \"blue\"\n        anchors.right: parent.right//设置rect3的右边锚点与窗口右边锚点对齐\n        anchors.top: parent.top//设置rect3的顶部锚点与窗口顶部锚点对齐\n    }\n}\n```\n![锚点布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/锚点布局.png)\n## 使用锚点代替宽、高设置\n```QML\nItem {\n      anchors.fill: parent\n\n      Rectangle{          //没设定x,y和锚点,默认在0,0位置\n          id:rect1\n          width: parent.width/3\n          height: parent.height\n          color: \"red\"\n             }\n      Rectangle{\n          id:rect2\n          width: parent.width/3\n          height: parent.height\n          color: \"green\"\n          anchors.left: rect1.right\n                }\n      Rectangle{\n          id: rect3\n          color: \"blue\"\n          anchors.right: parent.right //设置rect3的右边锚点与窗口右边锚点对齐\n          anchors.left: rect2.right   //设置rect3的顶部锚点与窗口顶部锚点对齐\n          anchors.top: parent.top     //设置rect3的顶部锚点与rect2顶部锚点对齐\n          anchors.bottom: parent.bottom//设置rect3的底部锚点与窗口底部锚点对齐\n\n              }\n    }\n```\n![锚点代替宽高](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/锚点代替宽高.png)\n## 行、列布局\n　　\n```QML\nItem {\n            anchors.fill: parent\n\n            ColumnLayout{           //列布局\n                id: layout1\n\n                RadioButton{\n                    checked: true\n                    text: '火锅'\n                }\n                RadioButton{\n                    text: '水饺'\n                }\n                RadioButton{\n                    text: '混沌'\n                }\n            }\n            RowLayout{              //行布局\n                id: layout2\n                anchors.left: layout1.right\n                anchors.leftMargin: 30\n                \n                RadioButton{\n                    checked: true\n                    text: '火锅'\n                }\n                RadioButton{\n                    text: '水饺'\n                }\n                RadioButton{\n                    text: '混沌'\n                }\n            }\n        }\n```\n![行、列布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/行、列布局.png)\n## FLOW流式布局\n　　将元素按照顺序依次排列，默认从左向右，元素宽度超过FLOW宽度后，自动向下排列  \n　　可通过｀flow: Flow.TopToBottom｀改变为从上向下\n```QML\nItem {\n        anchors.fill: parent\n        id:root\n\n        Flow {\n            id:flow1\n            anchors.left: parent.left\n            anchors.right: parent.right\n\n            Rectangle {\n                id:rect1\n                width:root.width/2\n                height:100\n                color: 'red'\n            }\n            Rectangle {\n                id:rect2\n                width:root.width/2\n                height:100\n                color: 'green'\n            }\n            Rectangle {\n                id:rect3\n                width:root.width/2\n                height:100\n                color: 'blue'\n            }\n        }\n        Flow {\n            anchors.left: parent.left\n            anchors.right: parent.right\n            anchors.top: flow1.bottom\n            flow: Flow.TopToBottom\n            \n            Rectangle {\n                id:rect4\n                width:root.width/2\n                height:100\n                color: 'red'\n            }\n            Rectangle {\n                id:rect5\n                width:root.width/2\n                height:100\n                color: 'green'\n            }\n        }\n    }\n```\n![flow流式布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/流式布局.png)\n## 网格布局\n　　将元素按照网格方式排列,默认从左向右依次排列,超过设置`列数`后自动向下排列\n```QML\nItem {\n        anchors.fill: parent\n        id:root\n\n        Grid {\n            columns: 3      //设置3列\n            spacing: 2      //设置每个元素之间的间距\n            Rectangle { color: \"red\"; width: 50; height: 50 }\n            Rectangle { color: \"green\"; width: 20; height: 50 }\n            Rectangle { color: \"blue\"; width: 50; height: 20 }\n            Rectangle { color: \"cyan\"; width: 50; height: 50 }\n            Rectangle { color: \"magenta\"; width: 10; height: 10 }\n        }\n    }\n```\n![Grid网格布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Grid网格布局.png)","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(二)","url":"/2022/07/21/QML/QML学习笔记(二)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## QML的信号与槽\n　　以Button为例,其信号函数在其父类中定义  \n![Button的信号函数](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Button的信号函数.png)\n　　槽函数的格式为，信号函数前加`on`且第一个字母大写,例:`clicked()`的槽函数为`onClicked:{  }`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Window 2.14\nimport QtQuick.Controls\nimport QtQuick.Layouts\n\nWindow {\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n        Button {                    //定义一个按钮\n            id: btn1                //按钮的ID\n            width: 60               //按钮的宽度\n            height: 30              //按钮的高度\n            text: \"Ok\"\n            //clicked()信号的槽函数\n            onClicked: {            //按钮按下触发的槽函数\n                console.log('btn click')//打印信息\n            }\n        }\n}\n```\n![Button的信号与槽](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Button的信号与槽.png)\n## 控件的属性\n　　以`Button`为例,其属性函数在其父类中定义  \n![Button的属性函数](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Button的属性函数.png)\n　　基本上每一个属性函数都有一个槽函数与之对应的变化的信号,例:`text`属性的变化信号为`textChanged`,对应的槽函数为`onTextChanged:{  }`  \n　　但是Qt文档里并没有提到这一点\n```QML\nonTextChanged: {                            //当text被改变时触发的槽函数\n                console.log('btn text',text)//打印被改变后的文字\n            }\n\n            //clicked()信号的槽函数\n            onClicked: {\n                console.log('btn click')\n                text = 'change'             //将text变为'change'\n            }\n```\n![Button属性的槽函数](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Button属性的槽函数.png)\n## 只读属性\n　　在属性中存在一种只读属性`only-read`,这种属性只能读取不能更改  \n　　例:`pressed:bool`，该属性保存按钮是否被物理按下。按钮可以通过触摸或按键事件来按下\n","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(一)","url":"/2022/07/21/QML/QML学习笔记(一)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n\n ## 创建一个QML工程\n\n　　创建QML工程时，选择创建Qt Quick项目\n\n![　](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/image-20220721131856526.png \"创建工程界面\")\n\n## 可视与不可视元素\n\n　　使用控件前需要导入对应的模块，例如：需要使用 Controls 控件在手册内寻找其对应模块，并引入模块\n\n![引入模块](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/image-20220721142837460.png)\n\n![手册中控件对应的模块](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/image-20220721143204201.png)\n　　可视元素为可以看到的元素，如：Button、Label  \n　　不可视元素为不可以看到的元素，如：Layout、RowLayout\n```QML\n  RowLayout {                           //不可视元素,竖排列\n        Button {                        //定义一个按钮\n            text: \"Ok\"                  //定义按钮的文字\n            onClicked: model.submit()   //定义按钮点击后触发效果\n        }\n        Button {                        //定义一个按钮\n            text: \"Cancel\"              //定义按钮的文字\n            onClicked: model.revert()   //定义按钮点击后触发效果\n        }\n    }\n    ColumnLayout{                       //不可视元素,横排列\n         x: 150                         //设置横排列的坐标\n         \n         Button {\n            text: \"Ok\"\n            onClicked: model.submit()\n        }\n         Button {\n            text: \"Cancel\"\n            onClicked: model.revert()\n        }\n    }\n```\n![可视与不可视元素](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/元素可视与不可视.png)\n## 子元素列表\n```QML\nItem {\n    anchors.fill: parent\n    id:root\n\n   Column {\n       id:cloumn\n\n       Rectangle{\n           width: 30\n           height: 30\n           color: \"red\"\n           property string name: 'rect1'\n       }\n       Rectangle{\n           width: 30\n           height: 30\n           color: \"blue\"\n           property string name: 'rect2'\n\n           Label{               //此项不属于column的子元素\n               text: 'label'\n           }\n       }\n       Component.onCompleted: {\n           console.log(cloumn.children.length)//取cloumn下的子元素个数\n           for(let i=0;i<cloumn.children.length;i++)    \n           {\n               console.log(cloumn.children[i].name)//遍历cloumn下的子元素的name项\n               console.log(cloumn.children[i].color)//遍历cloumn下的子元素的color项\n           }\n       }\n   }\n}\n```\n![子元素列表](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/子元素列表.png)","tags":["Qt","QML","笔记"],"categories":["Qt"]}]