[{"title":"Mysql数据库(三)","url":"/2023/11/21/Mysql/Mysql数据库(三)/","content":"\n---\n## DDL-表操作-修改\n### 1.添加字段\n```\nALTER TABLE 表名 ADD 字段名 类型(长度)[COMMENT 注释][约束];\n```\n> 👆 案例：\n> 为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)\n> <font color=green>ALTER TABLE emp ADD nickname varchar(20)COMMENT'昵称';</font>\n\n### 2.修改数据类型\n```\nALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n```\n### 3.修改字段名和字段类型\n```\nALTERTABLE 表名 CHANGE 旧字段名 新字段名类型(长度) [COMMENT注释] [约束];\n```\n> 👆 案例：\n>将emp表的nickname字段修改为username，类型为varchar(30)\n><font color=green>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT'昵称';</font>\n### 4.删除字段\n```\nALTER TABLE 表名 DROP 字段名;\n```\n> 👆 案例：\n>将emp表的字段username删除\n><font color=green>ALTER TABLE emp DROP username;</font>\n### 5.修改表名\n```\nALTER TABLE表名RENAME TO新表名;\n```\n> 👆 案例：\n>将emp表的表名修改为employee\n><font color=green>ALTER TABLE emp RENAME TO employee</font>\n### 6.删除表\n```\nDROP TABLE [IF EXISTI] 表名;\n```\n### 7.删除指定表，并重新创建改表\n```\nTRUNCATE TABLE 表名;\n```","tags":["MySQL"],"categories":["MySQL"]},{"title":"Mysql数据库(二)","url":"/2023/11/17/Mysql/Mysql数据库(二)/","content":"\n---\n## SQL通用语法\n>1. SQL语句可以单行或多行书写，以分号结尾。\n>2. SQL语句可以使用空格/缩进来增强语句的可读性。\n>3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n>4. 注释:\n  -单行注释:--注释内容或#注释内容(MySQL特有)\n  -多行注释:/* 注释内容 */\n\n## SQL分类\n|分类|全称|说明|\n|-|-|-|\nDDL|Data Definition Language|数据定义语言，用来定义数据库对象(数据库,表，字段)\nDML|Data Manipulation Language|数据操作语言，用来对数据库表中的数据进行增删改\nDQL|Data Query Language|数据查询语言，用来查询数据库中表的记录\nDCL|Data Control Language|数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n## DDL-数据库操作\n>查询所有数据库\n```\nSHOW DATABASES;//查询数据库服务器种所有的数据库\n```\n>查询当前数据库\n```\nSELECT DATABASE();//查询当前操作的数据库\n```\n>创建数据库\n```\nCREATE DATABASE [ IF NOT EXISTS]数据库名「 DEFAULTCHARSET字符集][ COLLATE排序规则];\n```\n创建名为“。。。”的数据库\n```\ncreate database 数据库名;\n```\n如果当前数据库服务器中不存在名为“。。。”的数据库，则创建名为“。。。”的数据库\n```\ncreate database if not exists 数据库名;\n```\n如果当前数据库服务器中不存在名为“。。。”的数据库，则创建名为“。。。”的数据库\n```\ncreate database if not exists 数据库名;\n```\n创建名为“。。。”的数据类型位utf8mb4的数据库\n```\ncreate database 数据库名 default charset utf8mb4;\n```\n>删除数据库\n```\nDROP DATABASE [ IF EXISTS]数据库名;\n```\n>使用数据库\n```\nUSE 数据库名;\n```\n\n## DDL-表操作-创建\n```\ncreate table 表名(\n  字段1 字段1类型[comment 字段1注释],\n  字段2 字段2类型[comment 字段2注释],\n  字段3 字段3类型[comment 字段3注释],\n  ...\n  字段n 字段n类型[comment 字段n注释]\n)[comment 表注释];\n```\n\n## DDL-表操作-查询\n查询当前数据库所有表\n```\nshow tables;\n```\n查询表结构\n```\ndesc 表名;\n```\n查询指定表的建表语句\n```\nshow create table 表名；\n```\n\n##　SQL数据类型\n### 数值类型\n<table>\n\t<tr>\n\t    <th>分类</th>\n\t    <th>类型</th>\n\t    <th>大小</th>  \n      <th>有符号（signed）范围</th>\n      <th>无符号（unsigned）范围</th>\n      <th>描述</th>  \n\t</tr >\n\t<tr >\n\t    <td rowspan=\"9\">数值类型</td>\n\t    <td>tinyint</td>\n\t    <td>1 byte</td>\n      <td>(-128,127)</td>\n      <td>(0,255)</td>\n      <td>小整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>smallint</td>\n\t    <td>2 byte</td>\n      <td>(-32768,32767)</td>\n      <td>(0,65535)</td>\n      <td>大整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>mediumint</td>\n\t    <td>3 byte</td>\n      <td>(-8388608,838867)</td>\n      <td>(0,16777215)</td>\n      <td>大整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>int或integer</td>\n\t    <td>4 byte</td>\n      <td>(-2147483648，2147483647)</td>\n      <td>(o，4294967295)</td>\n      <td>大整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>BIGINT</td>\n\t    <td>8 byte</td>\n      <td>(-2^63,2^63-1)</td>\n      <td>(0，2^64-1)</td>\n      <td>极大整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>FlOAT</td>\n\t    <td>4 byte</td>\n      <td>(-3.402823466E+38.3.402823466351 E+38)</td>\n      <td>0和(1.175494351 E-38，3.402823466 E+38)</td>\n      <td>单精度浮点数值</td>\n\t</tr>\n\t<tr >\n\t    <td>DOUBLE</td>\n\t    <td>8 byte</td>\n      <td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td>\n      <td>0和(2.2250738585072014 E-308，1.7976931348623157 E+308)</td>\n      <td>双精度浮点数值</td>\n\t</tr>\n\t<tr >\n\t    <td>DECIMAL</td>\n\t    <td></td>\n      <td>依赖于M(精度)和D(标度)的值</td>\n      <td>依赖于M(精度)和D(标度)的值</td>\n      <td>小数值(精确定点数)</td>\n\t</tr>\n</table>\n\n### 字符串类型\n<table>\n\t<tr>\n\t    <th>分类</th>\n\t    <th>类型</th>\n\t    <th>大小</th>  \n      <th>描述</th>  \n\t</tr >\n\t<tr >\n\t    <td rowspan=\"10\">字符串类型</td>\n\t    <td>CHAR</td>\n\t    <td>0-255 bytes</td>\n      <td>定长字符串</td>\n\t</tr>\n\t\t<tr >\n\t    <td>VARCHAR</td>\n\t    <td>0-65535 bytes</td>\n      <td>变长字符串</td>\n\t</tr>\n  \t\t<tr >\n\t    <td>TINYBLOB</td>\n\t    <td>0-255 bytes</td>\n      <td>不超过255个字符的二进制数据</td>\n\t</tr>\n    \t<tr >\n\t    <td>TINYTEXT</td>\n\t    <td>0-255 bytes</td>\n      <td>短文本字符串</td>\n\t</tr>\n    \t<tr >\n\t    <td>BLOB</td>\n\t    <td>0-65535 bytes</td>\n      <td>二进制形式的长文本数据</td>\n\t</tr>\n    \t<tr >\n\t    <td>TEXT</td>\n\t    <td>0-65 535 bytes</td>\n      <td>长文本数据</td>\n\t</tr>\n    \t<tr >\n\t    <td>MEDIUMBLOB</td>\n\t    <td>0-16 777 215 bytes</td>\n      <td>二进制形式的中等长度文本数据</td>\n\t</tr>\n    \t<tr >\n\t    <td>MEDIUMTEXT</td>\n\t    <td>0-16 777215 bytes</td>\n      <td>中等长度文本数据</td>\n\t</tr>\n      \t<tr >\n\t    <td>LONGBLOB</td>\n\t    <td>0-4 294 967 295 bytes</td>\n      <td>二进制形式的极大文本数据</td>\n\t</tr>\n      \t<tr >\n\t    <td>L.ONGTEXT</td>\n\t    <td>0-4 294 967 295 bytes</td>\n      <td>极大文本数据</td>\n\t</tr>\n</table>\n\n### 日期类型\n<table>\n\t<tr>\n\t    <th>分类</th>\n\t    <th>类型</th>\n\t    <th>大小</th> \n      <th>范围</th> \n      <th>格式</th>  \n      <th>描述</th>  \n\t</tr >\n\t<tr >\n\t    <td rowspan=\"5\">日期类型</td>\n\t    <td>DATE</td>\n\t    <td>3</td>\n      <td>1000-01-01 至9999-12-31</td>\n      <td>YYYY-MM-DD</td>\n      <td>日期值</td>\n\t</tr>\n\t<tr >\n\t    <td>TIME</td>\n\t    <td>3</td>\n      <td>-838:59:59 至838:59:59</td>\n      <td>HH :MM : ss</td>\n      <td>时间值或持续时间</td>\n\t</tr>\n\t<tr >\n\t    <td>YEAR</td>\n\t    <td>1</td>\n      <td>1901 至2155</td>\n      <td>YYYY</td>\n      <td>年份值</td>\n\t</tr>\n  \t<tr >\n\t    <td>DATETIME</td>\n\t    <td>8</td>\n      <td>1000-01-01 00:00:00至9999-12-31 23:59:59</td>\n      <td>YYYY一MM一DD HH:MM : ss</td>\n      <td>混合日期和时间值</td>\n\t</tr>\n    \t<tr >\n\t    <td>TIMESTAMP</td>\n\t    <td>4</td>\n      <td>1970-01-01 00:00:01至2038-01-19 03:14:07</td>\n      <td>YYYY一MM一DD HH:MM : ss</td>\n      <td>混合日期和时间值，时间戳</td>\n\t</tr>\n</table>","tags":["MySQL"],"categories":["MySQL"]},{"title":"Mysql数据库","url":"/2023/11/17/Mysql/MySQL/","content":"# 基础篇\n\n## 通用语法及分类\n\n- DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）\n- DML: 数据操作语言，用来对数据库表中的数据进行增删改\n- DQL: 数据查询语言，用来查询数据库中表的记录\n- DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限\n\n### DDL（数据定义语言）\n\n数据定义语言\n\n#### 数据库操作\n\n查询所有数据库：\n`SHOW DATABASES;`\n查询当前数据库：\n`SELECT DATABASE();`\n创建数据库：\n`CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];`\n删除数据库：\n`DROP DATABASE [ IF EXISTS ] 数据库名;`\n使用数据库：\n`USE 数据库名;`\n\n##### 注意事项\n\n- UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集\n\n#### 表操作\n\n查询当前数据库所有表：\n`SHOW TABLES;`\n查询表结构：\n`DESC 表名;`\n查询指定表的建表语句：\n`SHOW CREATE TABLE 表名;`\n\n创建表：\n```mysql\nCREATE TABLE 表名(\n\t字段1 字段1类型 [COMMENT 字段1注释],\n\t字段2 字段2类型 [COMMENT 字段2注释],\n\t字段3 字段3类型 [COMMENT 字段3注释],\n\t...\n\t字段n 字段n类型 [COMMENT 字段n注释]\n)[ COMMENT 表注释 ];\n```\n**最后一个字段后面没有逗号**\n\n添加字段：\n`ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];`\n例：`ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称';`\n\n修改数据类型：\n`ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);`\n修改字段名和字段类型：\n`ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];`\n例：将emp表的nickname字段修改为username，类型为varchar(30)\n`ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称';`\n\n删除字段：\n`ALTER TABLE 表名 DROP 字段名;`\n\n修改表名：\n`ALTER TABLE 表名 RENAME TO 新表名`\n\n删除表：\n`DROP TABLE [IF EXISTS] 表名;`\n删除表，并重新创建该表：\n`TRUNCATE TABLE 表名;`\n\n### DML（数据操作语言）\n\n#### 添加数据\n\n指定字段：\n`INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);`\n全部字段：\n`INSERT INTO 表名 VALUES (值1, 值2, ...);`\n\n批量添加数据：\n`INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);`\n`INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);`\n\n##### 注意事项\n\n- 字符串和日期类型数据应该包含在引号中\n- 插入的数据大小应该在字段的规定范围内\n\n#### 更新和删除数据\n\n修改数据：\n`UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];`\n例：\n`UPDATE emp SET name = 'Jack' WHERE id = 1;`\n\n删除数据：\n`DELETE FROM 表名 [ WHERE 条件 ];`\n\n### DQL（数据查询语言）\n\n语法：\n```mysql\nSELECT\n\t字段列表\nFROM\n\t表名字段\nWHERE\n\t条件列表\nGROUP BY\n\t分组字段列表\nHAVING\n\t分组后的条件列表\nORDER BY\n\t排序字段列表\nLIMIT\n\t分页参数\n```\n\n#### 基础查询\n\n查询多个字段：\n`SELECT 字段1, 字段2, 字段3, ... FROM 表名;`\n`SELECT * FROM 表名;`\n\n设置别名：\n`SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;`\n`SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;`\n\n去除重复记录：\n`SELECT DISTINCT 字段列表 FROM 表名;`\n\n转义：\n`SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'`\n/ 之后的\\_不作为通配符\n\n#### 条件查询\n\n语法：\n`SELECT 字段列表 FROM 表名 WHERE 条件列表;`\n\n条件：\n\n| 比较运算符          | 功能                                        |\n| ------------------- | ------------------------------------------- |\n| >                   | 大于                                        |\n| >=                  | 大于等于                                    |\n| <                   | 小于                                        |\n| <=                  | 小于等于                                    |\n| =                   | 等于                                        |\n| <> 或 !=            | 不等于                                      |\n| BETWEEN ... AND ... | 在某个范围内（含最小、最大值）              |\n| IN(...)             | 在in之后的列表中的值，多选一                |\n| LIKE 占位符         | 模糊匹配（\\_匹配单个字符，%匹配任意个字符） |\n| IS NULL             | 是NULL                                      |\n\n| 逻辑运算符         | 功能                         |\n| ------------------ | ---------------------------- |\n| AND 或 &&          | 并且（多个条件同时成立）     |\n| OR 或 &#124;&#124; | 或者（多个条件任意一个成立） |\n| NOT 或 !           | 非，不是                     |\n\n例子：\n```mysql\n-- 年龄等于30\nselect * from employee where age = 30;\n-- 年龄小于30\nselect * from employee where age < 30;\n-- 小于等于\nselect * from employee where age <= 30;\n-- 没有身份证\nselect * from employee where idcard is null or idcard = '';\n-- 有身份证\nselect * from employee where idcard;\nselect * from employee where idcard is not null;\n-- 不等于\nselect * from employee where age != 30;\n-- 年龄在20到30之间\nselect * from employee where age between 20 and 30;\nselect * from employee where age >= 20 and age <= 30;\n-- 下面语句不报错，但查不到任何信息\nselect * from employee where age between 30 and 20;\n-- 性别为女且年龄小于30\nselect * from employee where age < 30 and gender = '女';\n-- 年龄等于25或30或35\nselect * from employee where age = 25 or age = 30 or age = 35;\nselect * from employee where age in (25, 30, 35);\n-- 姓名为两个字\nselect * from employee where name like '__';\n-- 身份证最后为X\nselect * from employee where idcard like '%X';\n```\n\n#### 聚合查询（聚合函数）\n\n常见聚合函数：\n\n| 函数  | 功能     |\n| ----- | -------- |\n| count | 统计数量 |\n| max   | 最大值   |\n| min   | 最小值   |\n| avg   | 平均值   |\n| sum   | 求和     |\n\n语法：\n`SELECT 聚合函数(字段列表) FROM 表名;`\n例：\n`SELECT count(id) from employee where workaddress = \"广东省\";`\n\n#### 分组查询\n\n语法：\n`SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];`\n\nwhere 和 having 的区别：\n\n- 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。\n- 判断条件不同：where不能对聚合函数进行判断，而having可以。\n\n例子：\n\n```mysql\n-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）\nselect count(*) from employee group by gender;\n-- 根据性别分组，统计男性和女性数量\nselect gender, count(*) from employee group by gender;\n-- 根据性别分组，统计男性和女性的平均年龄\nselect gender, avg(age) from employee group by gender;\n-- 年龄小于45，并根据工作地址分组\nselect workaddress, count(*) from employee where age < 45 group by workaddress;\n-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址\nselect workaddress, count(*) address_count from employee where age < 45 group by workaddress having address_count >= 3;\n```\n\n##### 注意事项\n\n- 执行顺序：where > 聚合函数 > having\n- 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\n\n#### 排序查询\n\n语法：\n`SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;`\n\n排序方式：\n\n- ASC: 升序（默认）\n- DESC: 降序\n\n例子：\n\n```mysql\n-- 根据年龄升序排序\nSELECT * FROM employee ORDER BY age ASC;\nSELECT * FROM employee ORDER BY age;\n-- 两字段排序，根据年龄升序排序，入职时间降序排序\nSELECT * FROM employee ORDER BY age ASC, entrydate DESC;\n```\n\n##### 注意事项\n\n如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n\n#### 分页查询\n\n语法：\n`SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;`\n\n例子：\n\n```mysql\n-- 查询第一页数据，展示10条\nSELECT * FROM employee LIMIT 0, 10;\n-- 查询第二页\nSELECT * FROM employee LIMIT 10, 10;\n```\n\n##### 注意事项\n\n- 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数\n- 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT\n- 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10\n\n#### DQL执行顺序\n\nFROM -> WHERE -> GROUP BY -> SELECT -> ORDER BY -> LIMIT\n\n### DCL\n\n#### 管理用户\n\n查询用户：\n\n```mysql\nUSE mysql;\nSELECT * FROM user;\n```\n\n创建用户:\n`CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';`\n\n修改用户密码：\n`ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';`\n\n删除用户：\n`DROP USER '用户名'@'主机名';`\n\n例子：\n\n```mysql\n-- 创建用户test，只能在当前主机localhost访问\ncreate user 'test'@'localhost' identified by '123456';\n-- 创建用户test，能在任意主机访问\ncreate user 'test'@'%' identified by '123456';\ncreate user 'test' identified by '123456';\n-- 修改密码\nalter user 'test'@'localhost' identified with mysql_native_password by '1234';\n-- 删除用户\ndrop user 'test'@'localhost';\n```\n\n##### 注意事项\n\n- 主机名可以使用 % 通配\n\n#### 权限控制\n\n常用权限：\n\n| 权限                | 说明               |\n| ------------------- | ------------------ |\n| ALL, ALL PRIVILEGES | 所有权限           |\n| SELECT              | 查询数据           |\n| INSERT              | 插入数据           |\n| UPDATE              | 修改数据           |\n| DELETE              | 删除数据           |\n| ALTER               | 修改表             |\n| DROP                | 删除数据库/表/视图 |\n| CREATE              | 创建数据库/表      |\n\n更多权限请看[权限一览表](#权限一览表 \"权限一览表\")\n\n查询权限：\n`SHOW GRANTS FOR '用户名'@'主机名';`\n\n授予权限：\n`GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';`\n\n撤销权限：\n`REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';`\n\n##### 注意事项\n\n- 多个权限用逗号分隔\n- 授权时，数据库名和表名可以用 * 进行通配，代表所有\n\n## 函数\n\n- 字符串函数\n- 数值函数\n- 日期函数\n- 流程函数\n\n### 字符串函数\n\n常用函数：\n\n| 函数  | 功能  |\n| ------------ | ------------ |\n| CONCAT(s1, s2, ..., sn)  | 字符串拼接，将s1, s2, ..., sn拼接成一个字符串  |\n| LOWER(str)  | 将字符串全部转为小写  |\n| UPPER(str)  | 将字符串全部转为大写  |\n| LPAD(str, n, pad)  | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度  |\n| RPAD(str, n, pad)  | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度  |\n| TRIM(str)  | 去掉字符串头部和尾部的空格  |\n| SUBSTRING(str, start, len)  | 返回从字符串str从start位置起的len个长度的字符串  |\n| REPLACE(column, source, replace)  | 替换字符串  |\n\n使用示例：\n\n```mysql\n-- 拼接\nSELECT CONCAT('Hello', 'World');\n-- 小写\nSELECT LOWER('Hello');\n-- 大写\nSELECT UPPER('Hello');\n-- 左填充\nSELECT LPAD('01', 5, '-');\n-- 右填充\nSELECT RPAD('01', 5, '-');\n-- 去除空格\nSELECT TRIM(' Hello World ');\n-- 切片（起始索引为1）\nSELECT SUBSTRING('Hello World', 1, 5);\n```\n\n### 数值函数\n\n常见函数：\n\n| 函数  | 功能  |\n| ------------ | ------------ |\n| CEIL(x)  | 向上取整  |\n| FLOOR(x)  | 向下取整  |\n| MOD(x, y)  | 返回x/y的模  |\n| RAND() | 返回0~1内的随机数 |\n| ROUND(x, y) | 求参数x的四舍五入值，保留y位小数 |\n\n### 日期函数\n\n常用函数：\n\n| 函数  | 功能  |\n| ------------ | ------------ |\n| CURDATE()  | 返回当前日期  |\n| CURTIME()  | 返回当前时间  |\n| NOW()  | 返回当前日期和时间  |\n| YEAR(date)  | 获取指定date的年份  |\n| MONTH(date)  | 获取指定date的月份  |\n| DAY(date)  | 获取指定date的日期  |\n| DATE_ADD(date, INTERVAL expr type)  | 返回一个日期/时间值加上一个时间间隔expr后的时间值  |\n| DATEDIFF(date1, date2)  | 返回起始时间date1和结束时间date2之间的天数  |\n\n例子：\n\n```mysql\n-- DATE_ADD\nSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);\n```\n\n### 流程函数\n\n常用函数：\n\n| 函数  | 功能  |\n| ------------ | ------------ |\n| IF(value, t, f)  | 如果value为true，则返回t，否则返回f  |\n| IFNULL(value1, value2)  | 如果value1不为空，返回value1，否则返回value2  |\n| CASE WHEN [ val1 ] THEN [ res1 ] ... ELSE [ default ] END  | 如果val1为true，返回res1，... 否则返回default默认值  |\n| CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] ... ELSE [ default ] END  | 如果expr的值等于val1，返回res1，... 否则返回default默认值  |\n\n例子：\n\n```mysql\nselect\n\tname,\n\t(case when age > 30 then '中年' else '青年' end)\nfrom employee;\nselect\n\tname,\n\t(case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'\nfrom employee;\n```\n\n## 约束\n\n分类：\n\n| 约束  | 描述  | 关键字  |\n| ------------ | ------------ | ------------ |\n| 非空约束  | 限制该字段的数据不能为null  | NOT NULL  |\n| 唯一约束  | 保证该字段的所有数据都是唯一、不重复的  | UNIQUE  |\n| 主键约束  | 主键是一行数据的唯一标识，要求非空且唯一  | PRIMARY KEY  |\n| 默认约束  | 保存数据时，如果未指定该字段的值，则采用默认值  | DEFAULT  |\n| 检查约束（8.0.1版本后）  | 保证字段值满足某一个条件  | CHECK  |\n| 外键约束  | 用来让两张图的数据之间建立连接，保证数据的一致性和完整性  | FOREIGN KEY  |\n\n约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。\n\n### 常用约束\n\n| 约束条件  | 关键字  |\n| ------------ | ------------ |\n| 主键  | PRIMARY KEY  |\n| 自动增长  | AUTO_INCREMENT  |\n| 不为空  | NOT NULL  |\n| 唯一  | UNIQUE  |\n| 逻辑条件  | CHECK  |\n| 默认值  | DEFAULT  |\n\n例子：\n\n```mysql\ncreate table user(\n\tid int primary key auto_increment,\n\tname varchar(10) not null unique,\n\tage int check(age > 0 and age < 120),\n\tstatus char(1) default '1',\n\tgender char(1)\n);\n```\n\n### 外键约束\n\n添加外键：\n\n```mysql\nCREATE TABLE 表名(\n\t字段名 字段类型,\n\t...\n\t[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)\n);\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);\n\n-- 例子\nalter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);\n```\n\n删除外键：\n`ALTER TABLE 表名 DROP FOREIGN KEY 外键名;`\n\n#### 删除/更新行为\n\n| 行为  | 说明  |\n| ------------ | ------------ |\n| NO ACTION  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）  |\n| RESTRICT  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）  |\n| CASCADE  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录  |\n| SET NULL  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）  |\n| SET DEFAULT  | 父表有变更时，子表将外键设为一个默认值（Innodb不支持）  |\n\n更改删除/更新行为：\n`ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;`\n\n## 多表查询\n\n### 多表关系\n\n- 一对多（多对一）\n- 多对多\n- 一对一\n\n#### 一对多\n\n案例：部门与员工\n关系：一个部门对应多个员工，一个员工对应一个部门\n实现：在多的一方建立外键，指向一的一方的主键\n\n#### 多对多\n\n案例：学生与课程\n关系：一个学生可以选多门课程，一门课程也可以供多个学生选修\n实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n\n#### 一对一\n\n案例：用户与用户详情\n关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率\n实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\n\n### 查询\n\n合并查询（笛卡尔积，会展示所有组合结果）：\n`select * from employee, dept;`\n\n> 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）\n\n消除无效笛卡尔积：\n`select * from employee, dept where employee.dept = dept.id;`\n\n### 内连接查询\n\n内连接查询的是两张表交集的部分\n\n隐式内连接：\n`SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;`\n\n显式内连接：\n`SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;`\n\n显式性能比隐式高\n\n例子：\n\n```mysql\n-- 查询员工姓名，及关联的部门的名称\n-- 隐式\nselect e.name, d.name from employee as e, dept as d where e.dept = d.id;\n-- 显式\nselect e.name, d.name from employee as e inner join dept as d on e.dept = d.id;\n```\n\n### 外连接查询\n\n左外连接：\n查询左表所有数据，以及两张表交集部分数据\n`SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;`\n相当于查询表1的所有数据，包含表1和表2交集部分数据\n\n右外连接：\n查询右表所有数据，以及两张表交集部分数据\n`SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;`\n\n例子：\n\n```mysql\n-- 左\nselect e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;\nselect d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样\n-- 右\nselect d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;\n```\n\n左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept\n\n### 自连接查询\n\n当前表与自身的连接查询，自连接必须使用表别名\n\n语法：\n`SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;`\n\n自连接查询，可以是内连接查询，也可以是外连接查询\n\n例子：\n\n```mysql\n-- 查询员工及其所属领导的名字\nselect a.name, b.name from employee a, employee b where a.manager = b.id;\n-- 没有领导的也查询出来\nselect a.name, b.name from employee a left join employee b on a.manager = b.id;\n```\n\n### 联合查询 union, union all\n\n把多次查询的结果合并，形成一个新的查询集\n\n语法：\n\n```mysql\nSELECT 字段列表 FROM 表A ...\nUNION [ALL]\nSELECT 字段列表 FROM 表B ...\n```\n\n#### 注意事项\n\n- UNION ALL 会有重复结果，UNION 不会\n- 联合查询比使用or效率高，不会使索引失效\n\n### 子查询\n\nSQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。\n`SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);`\n**子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个**\n\n根据子查询结果可以分为：\n\n- 标量子查询（子查询结果为单个值）\n- 列子查询（子查询结果为一列）\n- 行子查询（子查询结果为一行）\n- 表子查询（子查询结果为多行多列）\n\n根据子查询位置可分为：\n\n- WHERE 之后\n- FROM 之后\n- SELECT 之后\n\n#### 标量子查询\n\n子查询返回的结果是单个值（数字、字符串、日期等）。\n常用操作符：- < > > >= < <=\n\n例子：\n\n```mysql\n-- 查询销售部所有员工\nselect id from dept where name = '销售部';\n-- 根据销售部部门ID，查询员工信息\nselect * from employee where dept = 4;\n-- 合并（子查询）\nselect * from employee where dept = (select id from dept where name = '销售部');\n\n-- 查询xxx入职之后的员工信息\nselect * from employee where entrydate > (select entrydate from employee where name = 'xxx');\n```\n\n#### 列子查询\n\n返回的结果是一列（可以是多行）。\n\n常用操作符：\n\n| 操作符  | 描述  |\n| ------------ | ------------ |\n| IN  | 在指定的集合范围内，多选一  |\n| NOT IN  | 不在指定的集合范围内  |\n| ANY  | 子查询返回列表中，有任意一个满足即可  |\n| SOME  | 与ANY等同，使用SOME的地方都可以使用ANY  |\n| ALL  | 子查询返回列表的所有值都必须满足  |\n\n例子：\n\n```mysql\n-- 查询销售部和市场部的所有员工信息\nselect * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');\n-- 查询比财务部所有人工资都高的员工信息\nselect * from employee where salary > all(select salary from employee where dept = (select id from dept where name = '财务部'));\n-- 查询比研发部任意一人工资高的员工信息\nselect * from employee where salary > any (select salary from employee where dept = (select id from dept where name = '研发部'));\n```\n\n#### 行子查询\n\n返回的结果是一行（可以是多列）。\n常用操作符：=, <, >, IN, NOT IN\n\n例子：\n\n```mysql\n-- 查询与xxx的薪资及直属领导相同的员工信息\nselect * from employee where (salary, manager) = (12500, 1);\nselect * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx');\n```\n\n#### 表子查询\n\n返回的结果是多行多列\n常用操作符：IN\n\n例子：\n\n```mysql\n-- 查询与xxx1，xxx2的职位和薪资相同的员工\nselect * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');\n-- 查询入职日期是2006-01-01之后的员工，及其部门信息\nselect e.*, d.* from (select * from employee where entrydate > '2006-01-01') as e left join dept as d on e.dept = d.id;\n```\n\n## 事务\n\n事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n\n基本操作：\n\n```mysql\n-- 1. 查询张三账户余额\nselect * from account where name = '张三';\n-- 2. 将张三账户余额-1000\nupdate account set money = money - 1000 where name = '张三';\n-- 此语句出错后张三钱减少但是李四钱没有增加\n模拟sql语句错误\n-- 3. 将李四账户余额+1000\nupdate account set money = money + 1000 where name = '李四';\n\n-- 查看事务提交方式\nSELECT @@AUTOCOMMIT;\n-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效\nSET @@AUTOCOMMIT = 0;\n-- 提交事务\nCOMMIT;\n-- 回滚事务\nROLLBACK;\n\n-- 设置手动提交后上面代码改为：\nselect * from account where name = '张三';\nupdate account set money = money - 1000 where name = '张三';\nupdate account set money = money + 1000 where name = '李四';\ncommit;\n```\n\n操作方式二：\n\n开启事务：\n`START TRANSACTION 或 BEGIN TRANSACTION;`\n提交事务：\n`COMMIT;`\n回滚事务：\n`ROLLBACK;`\n\n操作实例：\n\n```mysql\nstart transaction;\nselect * from account where name = '张三';\nupdate account set money = money - 1000 where name = '张三';\nupdate account set money = money + 1000 where name = '李四';\ncommit;\n```\n\n### 四大特性ACID\n\n- 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败\n- 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态\n- 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n- 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\n\n### 并发事务\n\n| 问题  | 描述  |\n| ------------ | ------------ |\n| 脏读  | 一个事务读到另一个事务还没提交的数据  |\n| 不可重复读  | 一个事务先后读取同一条记录，但两次读取的数据不同  |\n| 幻读  | 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在  |\n\n> 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd \n\n并发事务隔离级别：\n\n| 隔离级别  | 脏读  | 不可重复读  | 幻读  |\n| ------------ | ------------ | ------------ | ------------ |\n| Read uncommitted  | √  | √  | √  |\n| Read committed  | ×  | √  | √  |\n| Repeatable Read(默认)  | ×  | ×  | √  |\n| Serializable  | ×  | ×  | ×  |\n\n- √表示在当前隔离级别下该问题会出现\n- Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差\n\n查看事务隔离级别：\n`SELECT @@TRANSACTION_ISOLATION;`\n设置事务隔离级别：\n`SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };`\nSESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效\n\n# 进阶篇\n\n## 存储引擎\n\nMySQL体系结构：\n\n![结构图](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/MySQL体系结构_20220315034329549927.png \"结构图\")\n![层级描述](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/MySQL体系结构层级含义_20220315034359342837.png \"层级描述\")\n\n存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。\n默认存储引擎是InnoDB。\n\n相关操作：\n\n```mysql\n-- 查询建表语句\nshow create table account;\n-- 建表时指定存储引擎\nCREATE TABLE 表名(\n\t...\n) ENGINE=INNODB;\n-- 查看当前数据库支持的存储引擎\nshow engines;\n```\n\n### InnoDB\n\nInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。\n\n特点：\n\n- DML 操作遵循 ACID 模型，支持**事务**\n- **行级锁**，提高并发访问性能\n- 支持**外键**约束，保证数据的完整性和正确性\n\n文件：\n\n- xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。\n\n参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间\n\n知识点：\n\n查看 Mysql 变量：\n`show variables like 'innodb_file_per_table';`\n\n从idb文件提取表结构数据：\n（在cmd运行）\n`ibd2sdi xxx.ibd`\n\nInnoDB 逻辑存储结构：\n![InnoDB逻辑存储结构](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/逻辑存储结构_20220316030616590001.png \"InnoDB逻辑存储结构\")\n\n### MyISAM\n\nMyISAM 是 MySQL 早期的默认存储引擎。\n\n特点：\n\n- 不支持事务，不支持外键\n- 支持表锁，不支持行锁\n- 访问速度快\n\n文件：\n\n- xxx.sdi: 存储表结构信息\n- xxx.MYD: 存储数据\n- xxx.MYI: 存储索引\n\n### Memory\n\nMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。\n\n特点：\n\n- 存放在内存中，速度快\n- hash索引（默认）\n\n文件：\n\n- xxx.sdi: 存储表结构信息\n\n### 存储引擎特点\n\n| 特点  | InnoDB  | MyISAM  | Memory  |\n| ------------ | ------------ | ------------ | ------------ |\n| 存储限制  | 64TB  | 有  | 有  |\n| 事务安全  | 支持  | -  | -  |\n| 锁机制  | 行锁  | 表锁  | 表锁  |\n| B+tree索引  | 支持  | 支持  | 支持  |\n| Hash索引  | -  | -  | 支持  |\n| 全文索引  | 支持（5.6版本之后）  | 支持  | -  |\n| 空间使用  | 高  | 低  | N/A  |\n| 内存使用  | 高  | 低  | 中等  |\n| 批量插入速度  | 低  | 高  | 高  |\n| 支持外键  | 支持  | -  | -  |\n\n### 存储引擎的选择\n\n在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\n\n- InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择\n- MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。\n- Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性\n\n电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。\n\n## 性能分析\n\n### 查看执行频次\n\n查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：\n`SHOW GLOBAL STATUS LIKE 'Com_______';` 或者 `SHOW SESSION STATUS LIKE 'Com_______';`\n例：`show global status like 'Com_______'`\n\n### 慢查询日志\n\n慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\nMySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：\n\t# 开启慢查询日志开关\n\tslow_query_log=1\n\t# 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志\n\tlong_query_time=2\n更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log\n\n查看慢查询日志开关状态：\n`show variables like 'slow_query_log';`\n\n### profile\n\nshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：\n`SELECT @@have_profiling;`\nprofiling 默认关闭，可以通过set语句在session/global级别开启 profiling：\n`SET profiling = 1;`\n查看所有语句的耗时：\n`show profiles;`\n查看指定query_id的SQL语句各个阶段的耗时：\n`show profile for query query_id;`\n查看指定query_id的SQL语句CPU的使用情况\n`show profile cpu for query query_id;`\n\n### explain\n\nEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。\n语法：\n\t# 直接在select语句之前加上关键字 explain / desc\n\tEXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;\n\nEXPLAIN 各字段含义：\n\n- id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）\n- select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等\n- type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all\n- possible_key：可能应用在这张表上的索引，一个或多个\n- Key：实际使用的索引，如果为 NULL，则没有使用索引\n- Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好\n- rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的\n- filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好\n\n## 索引\n\n索引是帮助 MySQL **高效获取数据**的**数据结构（有序）**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。\n\n优缺点：\n\n优点：\n\n- 提高数据检索效率，降低数据库的IO成本\n- 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗\n\n缺点：\n\n- 索引列也是要占用空间的\n- 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE\n\n### 索引结构\n\n| 索引结构  | 描述  |\n| ------------ | ------------ |\n| B+Tree  | 最常见的索引类型，大部分引擎都支持B+树索引  |\n| Hash  | 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询  |\n| R-Tree(空间索引)  | 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少  |\n| Full-Text(全文索引)  | 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES  |\n\n| 索引  | InnoDB  | MyISAM  | Memory  |\n| ------------ | ------------ | ------------ | ------------ |\n| B+Tree索引  | 支持  | 支持  | 支持  |\n| Hash索引  | 不支持  | 不支持  | 支持  |\n| R-Tree索引  | 不支持  | 支持  | 不支持  |\n| Full-text  | 5.6版本后支持  | 支持  | 不支持  |\n\n#### B-Tree\n\n![二叉树](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/二叉树_20220316153214227108.png \"二叉树\")\n\n二叉树的缺点可以用红黑树来解决：\n![红黑树](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/红黑树_20220316163142686602.png \"红黑树\")\n红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。\n\n为了解决上述问题，可以使用 B-Tree 结构。\nB-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）\n\n![B-Tree结构](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/B-Tree结构_20220316163813441163.png \"B-Tree结构\")\n\n> B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68\n演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html\n\n#### B+Tree\n\n结构图：\n\n![B+Tree结构图](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/B+Tree结构图_20220316170700591277.png \"B+Tree结构图\")\n\n> 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\n\n与 B-Tree 的区别：\n\n- 所有的数据都会出现在叶子节点\n- 叶子节点形成一个单向链表\n\nMySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。\n\n![MySQL B+Tree 结构图](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/结构图_20220316171730865611.png \"MySQL B+Tree 结构图\")\n\n#### Hash\n\n哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。\n如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。\n\n![Hash索引原理图](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/Hash索引原理图_20220317143226150679.png \"Hash索引原理图\")\n\n特点：\n\n- Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、>、<、...）\n- 无法利用索引完成排序操作\n- 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引\n\n存储引擎支持：\n\n- Memory\n- InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的\n\n#### 面试题\n\n1. 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？\n\n- 相对于二叉树，层级更少，搜索效率高\n- 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低\n- 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作\n\n### 索引分类\n\n| 分类  | 含义  | 特点  | 关键字  |\n| ------------ | ------------ | ------------ | ------------ |\n| 主键索引  | 针对于表中主键创建的索引  | 默认自动创建，只能有一个  | PRIMARY  |\n| 唯一索引  | 避免同一个表中某数据列中的值重复  | 可以有多个  | UNIQUE  |\n| 常规索引  | 快速定位特定数据  | 可以有多个  |   |\n| 全文索引  | 全文索引查找的是文本中的关键词，而不是比较索引中的值  | 可以有多个  | FULLTEXT  |\n\n在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n| 分类  | 含义  | 特点  |\n| ------------ | ------------ | ------------ |\n| 聚集索引(Clustered Index)  | 将数据存储与索引放一块，索引结构的叶子节点保存了行数据  | 必须有，而且只有一个  |\n| 二级索引(Secondary Index)  | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键  | 可以存在多个  |\n\n演示图：\n\n![大致原理](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/原理图_20220318194454880073.png \"大致原理\")\n![演示图](https://learning-logs-1253130399.cos.ap-guangzhou.myqcloud.com/editor/演示图_20220319215403721066.png \"演示图\")\n\n聚集索引选取规则：\n\n- 如果存在主键，主键索引就是聚集索引\n- 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引\n- 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引\n\n#### 思考题\n\n1\\. 以下 SQL 语句，哪个执行效率高？为什么？\n\n```mysql\nselect * from user where id = 10;\nselect * from user where name = 'Arm';\n-- 备注：id为主键，name字段创建的有索引\n```\n\n答：第一条语句，因为第二条需要回表查询，相当于两个步骤。\n\n2\\. InnoDB 主键索引的 B+Tree 高度为多少？\n\n答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.\n可得公式：`n * 8 + (n + 1) * 6 = 16 * 1024`，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。\n\n如果树的高度为2，那么他能存储的数据量大概为：`1171 * 16 = 18736`；\n如果树的高度为3，那么他能存储的数据量大概为：`1171 * 1171 * 16 = 21939856`。\n\n另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。\n\n### 语法\n\n创建索引：\n`CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);`\n如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引\n\n查看索引：\n`SHOW INDEX FROM table_name;`\n\n删除索引：\n`DROP INDEX index_name ON table_name;`\n\n案例：\n\n```mysql\n-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引\ncreate index idx_user_name on tb_user(name);\n-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引\ncreate unique index idx_user_phone on tb_user (phone);\n-- 为profession, age, status创建联合索引\ncreate index idx_user_pro_age_stat on tb_user(profession, age, status);\n-- 为email建立合适的索引来提升查询效率\ncreate index idx_user_email on tb_user(email);\n\n-- 删除索引\ndrop index idx_user_email on tb_user;\n```\n\n### 使用规则\n\n#### 最左前缀法则\n\n如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。\n如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n\n联合索引中，出现范围查询（<, >），范围查询右侧的列索引失效。可以用>=或者<=来规避索引失效问题。\n\n#### 索引失效情况\n\n1. 在索引列上进行运算操作，索引将失效。如：`explain select * from tb_user where substring(phone, 10, 2) = '15';`\n2. 字符串类型字段使用时，不加引号，索引将失效。如：`explain select * from tb_user where phone = 17799990015;`，此处phone的值没有加引号\n3. 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：`explain select * from tb_user where profession like '%工程';`，前后都有 % 也会失效。\n4. 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。\n5. 如果 MySQL 评估使用索引比全表更慢，则不使用索引。\n\n#### SQL 提示\n\n是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n\n例如，使用索引：\n`explain select * from tb_user use index(idx_user_pro) where profession=\"软件工程\";`\n不使用哪个索引：\n`explain select * from tb_user ignore index(idx_user_pro) where profession=\"软件工程\";`\n必须使用哪个索引：\n`explain select * from tb_user force index(idx_user_pro) where profession=\"软件工程\";`\n\nuse 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。\n\n#### 覆盖索引&回表查询\n\n尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。\n\nexplain 中 extra 字段含义：\n`using index condition`：查找使用了索引，但是需要回表查询数据\n`using where; using index;`：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询\n\n如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select \\*；如果在辅助索引中找聚集索引，如`select id, name from xxx where name='xxx';`，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如`select id, name, gender from xxx where name='xxx';`\n\n所以尽量不要用`select *`，容易出现回表查询，降低效率，除非有联合索引包含了所有字段\n\n面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：\n`select id, username, password from tb_user where username='itcast';`\n\n解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引\n\n#### 前缀索引\n\n当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n\n语法：`create index idx_xxxx on table_name(columnn(n));`\n前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。\n求选择性公式：\n```mysql\nselect count(distinct email) / count(*) from tb_user;\nselect count(distinct substring(email, 1, 5)) / count(*) from tb_user;\n```\n\nshow index 里面的sub_part可以看到接取的长度\n\n#### 单列索引&联合索引\n\n单列索引：即一个索引只包含单个列\n联合索引：即一个索引包含了多个列\n在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n\n单列索引情况：\n`explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';`\n这句只会用到phone索引字段\n\n##### 注意事项\n\n- 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询\n\n### 设计原则\n\n1. 针对于数据量较大，且查询比较频繁的表建立索引\n2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引\n3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高\n4. 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引\n5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率\n6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率\n7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询\n\n## SQL 优化\n\n### 插入数据\n\n普通插入：\n\n1. 采用批量插入（一次插入的数据不建议超过1000条）\n2. 手动提交事务\n3. 主键顺序插入\n\n大批量插入：\n如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。\n\n```mysql\n# 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）\nmysql --local-infile -u root -p\n# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关\nset global local_infile = 1;\nselect @@local_infile;\n# 执行load指令将准备好的数据，加载到表结构中\nload data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\\n';\n```\n\n### 主键优化\n\n数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）\n\n页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。\n页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。\n\nMERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定\n\n> 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90\n\n主键设计原则：\n\n- 满足业务需求的情况下，尽量降低主键的长度\n- 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键\n- 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号\n- 业务操作时，避免对主键的修改\n\n### order by优化\n\n1. Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序\n2. Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高\n\n如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是`Using index, Using filesort`，如果要优化掉Using filesort，则需要另外再创建一个索引，如：`create index idx_user_age_phone_ad on tb_user(age asc, phone desc);`，此时使用`select id, age, phone from tb_user order by age asc, phone desc;`会全部走索引\n\n总结：\n\n- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则\n- 尽量使用覆盖索引\n- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）\n- 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）\n\n### group by优化\n\n- 在分组操作时，可以通过索引来提高效率\n- 分组操作时，索引的使用也是满足最左前缀法则的\n\n如索引为`idx_user_pro_age_stat`，则句式可以是`select ... where profession order by age`，这样也符合最左前缀法则\n\n### limit优化\n\n常见的问题如`limit 2000000, 10`，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。\n优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n\n例如：\n\n```mysql\n-- 此语句耗时很长\nselect * from tb_sku limit 9000000, 10;\n-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询\nselect id from tb_sku order by id limit 9000000, 10;\n-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit\n-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);\n-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度\nselect * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;\n```\n\n### count优化\n\nMyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(\\*) 的时候会直接返回这个数，效率很高（前提是不适用where）；\nInnoDB 在执行 count(\\*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。\n优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis\n\ncount的几种用法：\n\n- 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值\n- 用法：count(\\*)、count(主键)、count(字段)、count(1)\n- count(主键)跟count(\\*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(\\*)一样；count(null)返回0\n\n各种用法的性能：\n\n- count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）\n- count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加\n- count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加\n- count(\\*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加\n\n按效率排序：count(字段) < count(主键) < count(1) < count(\\*)，所以尽量使用 count(\\*)\n\n### update优化（避免行锁升级为表锁）\n\nInnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。\n\n如以下两条语句：\n`update student set no = '123' where id = 1;`，这句由于id有主键索引，所以只会锁这一行；\n`update student set no = '123' where name = 'test';`，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引\n\n# 数据类型\n\n## 整型\n\n| 类型名称      | 取值范围                                  | 大小    |\n| ------------- | ----------------------------------------- | ------- |\n| TINYINT       | -128〜127                                 | 1个字节 |\n| SMALLINT      | -32768〜32767                             | 2个宇节 |\n| MEDIUMINT     | -8388608〜8388607                         | 3个字节 |\n| INT (INTEGHR) | -2147483648〜2147483647                   | 4个字节 |\n| BIGINT        | -9223372036854775808〜9223372036854775807 | 8个字节 |\n\n无符号在数据类型后加 unsigned 关键字。\n\n## 浮点型\n\n| 类型名称            | 说明               | 存储需求   |\n| ------------------- | ------------------ | ---------- |\n| FLOAT               | 单精度浮点数       | 4 个字节   |\n| DOUBLE              | 双精度浮点数       | 8 个字节   |\n| DECIMAL (M, D)，DEC | 压缩的“严格”定点数 | M+2 个字节 |\n\n## 日期和时间\n\n| 类型名称  | 日期格式            | 日期范围                                          | 存储需求 |\n| --------- | ------------------- | ------------------------------------------------- | -------- |\n| YEAR      | YYYY                | 1901 ~ 2155                                       | 1 个字节 |\n| TIME      | HH:MM:SS            | -838:59:59 ~ 838:59:59                            | 3 个字节 |\n| DATE      | YYYY-MM-DD          | 1000-01-01 ~ 9999-12-3                            | 3 个字节 |\n| DATETIME  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59         | 8 个字节 |\n| TIMESTAMP | YYYY-MM-DD HH:MM:SS | 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC | 4 个字节 |\n\n## 字符串\n\n| 类型名称   | 说明                                         | 存储需求                                                   |\n| ---------- | -------------------------------------------- | ---------------------------------------------------------- |\n| CHAR(M)    | 固定长度非二进制字符串                       | M 字节，1<=M<=255                                          |\n| VARCHAR(M) | 变长非二进制字符串                           | L+1字节，在此，L< = M和 1<=M<=255                          |\n| TINYTEXT   | 非常小的非二进制字符串                       | L+1字节，在此，L<2^8                                       |\n| TEXT       | 小的非二进制字符串                           | L+2字节，在此，L<2^16                                      |\n| MEDIUMTEXT | 中等大小的非二进制字符串                     | L+3字节，在此，L<2^24                                      |\n| LONGTEXT   | 大的非二进制字符串                           | L+4字节，在此，L<2^32                                      |\n| ENUM       | 枚举类型，只能有一个枚举字符串值             | 1或2个字节，取决于枚举值的数目 (最大值为65535)             |\n| SET        | 一个设置，字符串对象可以有零个或 多个SET成员 | 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） |\n\n## 二进制类型\n\n| 类型名称       | 说明                 | 存储需求               |\n| -------------- | -------------------- | ---------------------- |\n| BIT(M)         | 位字段类型           | 大约 (M+7)/8 字节      |\n| BINARY(M)      | 固定长度二进制字符串 | M 字节                 |\n| VARBINARY (M)  | 可变长度二进制字符串 | M+1 字节               |\n| TINYBLOB (M)   | 非常小的BLOB         | L+1 字节，在此，L<2^8  |\n| BLOB (M)       | 小 BLOB              | L+2 字节，在此，L<2^16 |\n| MEDIUMBLOB (M) | 中等大小的BLOB       | L+3 字节，在此，L<2^24 |\n| LONGBLOB (M)   | 非常大的BLOB         | L+4 字节，在此，L<2^32 |\n\n# 权限一览表\n\n> 具体权限的作用详见[官方文档](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html \"官方文档\")\n\nGRANT 和 REVOKE 允许的静态权限\n\n| Privilege                                                    | Grant Table Column           | Context                               |\n| :----------------------------------------------------------- | :--------------------------- | :------------------------------------ |\n| [`ALL [PRIVILEGES]`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all) | Synonym for “all privileges” | Server administration                 |\n| [`ALTER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter) | `Alter_priv`                 | Tables                                |\n| [`ALTER ROUTINE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine) | `Alter_routine_priv`         | Stored routines                       |\n| [`CREATE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create) | `Create_priv`                | Databases, tables, or indexes         |\n| [`CREATE ROLE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role) | `Create_role_priv`           | Server administration                 |\n| [`CREATE ROUTINE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine) | `Create_routine_priv`        | Stored routines                       |\n| [`CREATE TABLESPACE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace) | `Create_tablespace_priv`     | Server administration                 |\n| [`CREATE TEMPORARY TABLES`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables) | `Create_tmp_table_priv`      | Tables                                |\n| [`CREATE USER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user) | `Create_user_priv`           | Server administration                 |\n| [`CREATE VIEW`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view) | `Create_view_priv`           | Views                                 |\n| [`DELETE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete) | `Delete_priv`                | Tables                                |\n| [`DROP`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop) | `Drop_priv`                  | Databases, tables, or views           |\n| [`DROP ROLE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role) | `Drop_role_priv`             | Server administration                 |\n| [`EVENT`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event) | `Event_priv`                 | Databases                             |\n| [`EXECUTE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute) | `Execute_priv`               | Stored routines                       |\n| [`FILE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file) | `File_priv`                  | File access on server host            |\n| [`GRANT OPTION`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option) | `Grant_priv`                 | Databases, tables, or stored routines |\n| [`INDEX`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index) | `Index_priv`                 | Tables                                |\n| [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert) | `Insert_priv`                | Tables or columns                     |\n| [`LOCK TABLES`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables) | `Lock_tables_priv`           | Databases                             |\n| [`PROCESS`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process) | `Process_priv`               | Server administration                 |\n| [`PROXY`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy) | See `proxies_priv` table     | Server administration                 |\n| [`REFERENCES`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references) | `References_priv`            | Databases or tables                   |\n| [`RELOAD`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload) | `Reload_priv`                | Server administration                 |\n| [`REPLICATION CLIENT`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client) | `Repl_client_priv`           | Server administration                 |\n| [`REPLICATION SLAVE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave) | `Repl_slave_priv`            | Server administration                 |\n| [`SELECT`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select) | `Select_priv`                | Tables or columns                     |\n| [`SHOW DATABASES`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases) | `Show_db_priv`               | Server administration                 |\n| [`SHOW VIEW`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view) | `Show_view_priv`             | Views                                 |\n| [`SHUTDOWN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown) | `Shutdown_priv`              | Server administration                 |\n| [`SUPER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super) | `Super_priv`                 | Server administration                 |\n| [`TRIGGER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger) | `Trigger_priv`               | Tables                                |\n| [`UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update) | `Update_priv`                | Tables or columns                     |\n| [`USAGE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage) | Synonym for “no privileges”  | Server administration                 |\n\nGRANT 和 REVOKE 允许的动态权限\n\n| Privilege                                                    | Context                                           |\n| :----------------------------------------------------------- | :------------------------------------------------ |\n| [`APPLICATION_PASSWORD_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin) | Dual password administration                      |\n| [`AUDIT_ABORT_EXEMPT`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt) | Allow queries blocked by audit log filter         |\n| [`AUDIT_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin) | Audit log administration                          |\n| [`AUTHENTICATION_POLICY_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin) | Authentication administration                     |\n| [`BACKUP_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin) | Backup administration                             |\n| [`BINLOG_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin) | Backup and Replication administration             |\n| [`BINLOG_ENCRYPTION_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin) | Backup and Replication administration             |\n| [`CLONE_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin) | Clone administration                              |\n| [`CONNECTION_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin) | Server administration                             |\n| [`ENCRYPTION_KEY_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin) | Server administration                             |\n| [`FIREWALL_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin) | Firewall administration                           |\n| [`FIREWALL_EXEMPT`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt) | Firewall administration                           |\n| [`FIREWALL_USER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user) | Firewall administration                           |\n| [`FLUSH_OPTIMIZER_COSTS`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs) | Server administration                             |\n| [`FLUSH_STATUS`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status) | Server administration                             |\n| [`FLUSH_TABLES`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables) | Server administration                             |\n| [`FLUSH_USER_RESOURCES`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources) | Server administration                             |\n| [`GROUP_REPLICATION_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin) | Replication administration                        |\n| [`GROUP_REPLICATION_STREAM`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream) | Replication administration                        |\n| [`INNODB_REDO_LOG_ARCHIVE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive) | Redo log archiving administration                 |\n| [`NDB_STORED_USER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user) | NDB Cluster                                       |\n| [`PASSWORDLESS_USER_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin) | Authentication administration                     |\n| [`PERSIST_RO_VARIABLES_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin) | Server administration                             |\n| [`REPLICATION_APPLIER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier) | `PRIVILEGE_CHECKS_USER` for a replication channel |\n| [`REPLICATION_SLAVE_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin) | Replication administration                        |\n| [`RESOURCE_GROUP_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin) | Resource group administration                     |\n| [`RESOURCE_GROUP_USER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user) | Resource group administration                     |\n| [`ROLE_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin) | Server administration                             |\n| [`SESSION_VARIABLES_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin) | Server administration                             |\n| [`SET_USER_ID`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id) | Server administration                             |\n| [`SHOW_ROUTINE`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine) | Server administration                             |\n| [`SYSTEM_USER`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user) | Server administration                             |\n| [`SYSTEM_VARIABLES_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin) | Server administration                             |\n| [`TABLE_ENCRYPTION_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin) | Server administration                             |\n| [`VERSION_TOKEN_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin) | Server administration                             |\n| [`XA_RECOVER_ADMIN`](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin) | Server administration                             |\n\n# 图形化界面工具\n\n- Workbench(免费): http://dev.mysql.com/downloads/workbench/\n- navicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql\n- Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/\n- HeidiSQL(免费): http://www.heidisql.com/\n- phpMyAdmin(免费): https://www.phpmyadmin.net/\n- SQLyog: https://sqlyog.en.softonic.com/\n\n# 安装\n\n# 小技巧\n\n1. 在SQL语句之后加上`\\G`会将结果的表格形式转换成行文本形式\n2. 查看Mysql数据库占用空间：\n```mysql\nSELECT table_schema \"Database Name\"\n     , SUM(data_length + index_length) / (1024 * 1024) \"Database Size in MB\"\nFROM information_schema.TABLES\nGROUP BY table_schema;\n```\n\n# 后续内容\n\n后续内容因为跟当前学习、工作计划有冲突，所以后续课程的学习计划会无限期推后。\n目前的工作重点放在重做一个学习笔记网站，当然这是边做边学的，开发过程中遇到的难点和知识点我也会记录下来供大家学习。\n**在此感谢B站同样爱学习的同学 @守心-人 提供的后续课程笔记，大家有条件一定要去给个star，你的每一个star和点赞都是我们前进的动力**\n**[https://github.com/Buildings-Lei/mysql_note/blob/main/README.md](https://github.com/Buildings-Lei/mysql_note/blob/main/README.md)**","tags":["MySQL"],"categories":["MySQL"]},{"title":"Mysql数据库(一)","url":"/2023/11/17/Mysql/Mysql数据库(一)/","content":"\n---\n## Mysql的启动、停止和连接\n>Mysql服务启动\n```\n net start mysql80\n```\n\n>Mysql服务停止\n```\n net stop mysql80\n```\n\n>Mysql客户端连接\n  -通过Mysql自带客户端命令行连接\n  -通过win控制台连接\n```\n mysql [-h 127.0.0.1] [-p 3306] -u root -p\n```\n```\n mysql -u root -p\n```\n## Mysql的数据模型\n关系型数据库  \n  >概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n  ![二维表关系图](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-11-17-1.png)\n  >特点：  \n  -- 1.使用表存储数据，格式同意，便于维护；  \n  -- 2.使用SQL语言操作，标准统一，使用方便。  \n\n数据模型\n  -客户端通过数据库操作系统（DBMS），使用SQL语句操作数据库；\n  -一个数据库服务器可包含多个数据库，一个数据库可包含多个表；\n  ![数据模型图](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-11-17-2.png)\n","tags":["MySQL"],"categories":["MySQL"]},{"title":"Mysql数据库","url":"/2023/11/17/Mysql/Mysql数据库/","content":"## Mysql操作\n|操作名称|操作命令\n|-|-|\nMysql服务启动|net start mysql80\nMysql服务停止|net stop mysql80\nMysql客户端连接|mysql -u root -p  \n\n##　1. SQL数据类型\n### 数值类型\n<table>\n\t<tr>\n\t    <th>分类</th>\n\t    <th>类型</th>\n\t    <th>大小</th>  \n      <th>有符号（signed）范围</th>\n      <th>无符号（unsigned）范围</th>\n      <th>描述</th>  \n\t</tr >\n\t<tr >\n\t    <td rowspan=\"9\">数值类型</td>\n\t    <td>tinyint</td>\n\t    <td>1 byte</td>\n      <td>(-128,127)</td>\n      <td>(0,255)</td>\n      <td>小整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>smallint</td>\n\t    <td>2 byte</td>\n      <td>(-32768,32767)</td>\n      <td>(0,65535)</td>\n      <td>大整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>mediumint</td>\n\t    <td>3 byte</td>\n      <td>(-8388608,838867)</td>\n      <td>(0,16777215)</td>\n      <td>大整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>int或integer</td>\n\t    <td>4 byte</td>\n      <td>(-2147483648，2147483647)</td>\n      <td>(o，4294967295)</td>\n      <td>大整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>BIGINT</td>\n\t    <td>8 byte</td>\n      <td>(-2^63,2^63-1)</td>\n      <td>(0，2^64-1)</td>\n      <td>极大整数值</td>\n\t</tr>\n\t<tr >\n\t    <td>FlOAT</td>\n\t    <td>4 byte</td>\n      <td>(-3.402823466E+38.3.402823466351 E+38)</td>\n      <td>0和(1.175494351 E-38，3.402823466 E+38)</td>\n      <td>单精度浮点数值</td>\n\t</tr>\n\t<tr >\n\t    <td>DOUBLE</td>\n\t    <td>8 byte</td>\n      <td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td>\n      <td>0和(2.2250738585072014 E-308，1.7976931348623157 E+308)</td>\n      <td>双精度浮点数值</td>\n\t</tr>\n\t<tr >\n\t    <td>DECIMAL</td>\n\t    <td></td>\n      <td>依赖于M(精度)和D(标度)的值</td>\n      <td>依赖于M(精度)和D(标度)的值</td>\n      <td>小数值(精确定点数)</td>\n\t</tr>\n</table>\n\n### 字符串类型\n<table>\n\t<tr>\n\t    <th>分类</th>\n\t    <th>类型</th>\n\t    <th>大小</th>  \n      <th>描述</th>  \n\t</tr >\n\t<tr >\n\t    <td rowspan=\"10\">字符串类型</td>\n\t    <td>CHAR</td>\n\t    <td>0-255 bytes</td>\n      <td>定长字符串</td>\n\t</tr>\n\t\t<tr >\n\t    <td>VARCHAR</td>\n\t    <td>0-65535 bytes</td>\n      <td>变长字符串</td>\n\t</tr>\n  \t\t<tr >\n\t    <td>TINYBLOB</td>\n\t    <td>0-255 bytes</td>\n      <td>不超过255个字符的二进制数据</td>\n\t</tr>\n    \t<tr >\n\t    <td>TINYTEXT</td>\n\t    <td>0-255 bytes</td>\n      <td>短文本字符串</td>\n\t</tr>\n    \t<tr >\n\t    <td>BLOB</td>\n\t    <td>0-65535 bytes</td>\n      <td>二进制形式的长文本数据</td>\n\t</tr>\n    \t<tr >\n\t    <td>TEXT</td>\n\t    <td>0-65 535 bytes</td>\n      <td>长文本数据</td>\n\t</tr>\n    \t<tr >\n\t    <td>MEDIUMBLOB</td>\n\t    <td>0-16 777 215 bytes</td>\n      <td>二进制形式的中等长度文本数据</td>\n\t</tr>\n    \t<tr >\n\t    <td>MEDIUMTEXT</td>\n\t    <td>0-16 777215 bytes</td>\n      <td>中等长度文本数据</td>\n\t</tr>\n      \t<tr >\n\t    <td>LONGBLOB</td>\n\t    <td>0-4 294 967 295 bytes</td>\n      <td>二进制形式的极大文本数据</td>\n\t</tr>\n      \t<tr >\n\t    <td>L.ONGTEXT</td>\n\t    <td>0-4 294 967 295 bytes</td>\n      <td>极大文本数据</td>\n\t</tr>\n</table>\n\n### 日期类型\n<table>\n\t<tr>\n\t    <th>分类</th>\n\t    <th>类型</th>\n\t    <th>大小</th> \n      <th>范围</th> \n      <th>格式</th>  \n      <th>描述</th>  \n\t</tr >\n\t<tr >\n\t    <td rowspan=\"5\">日期类型</td>\n\t    <td>DATE</td>\n\t    <td>3</td>\n      <td>1000-01-01 至9999-12-31</td>\n      <td>YYYY-MM-DD</td>\n      <td>日期值</td>\n\t</tr>\n\t<tr >\n\t    <td>TIME</td>\n\t    <td>3</td>\n      <td>-838:59:59 至838:59:59</td>\n      <td>HH :MM : ss</td>\n      <td>时间值或持续时间</td>\n\t</tr>\n\t<tr >\n\t    <td>YEAR</td>\n\t    <td>1</td>\n      <td>1901 至2155</td>\n      <td>YYYY</td>\n      <td>年份值</td>\n\t</tr>\n  \t<tr >\n\t    <td>DATETIME</td>\n\t    <td>8</td>\n      <td>1000-01-01 00:00:00至9999-12-31 23:59:59</td>\n      <td>YYYY一MM一DD HH:MM : ss</td>\n      <td>混合日期和时间值</td>\n\t</tr>\n    \t<tr >\n\t    <td>TIMESTAMP</td>\n\t    <td>4</td>\n      <td>1970-01-01 00:00:01至2038-01-19 03:14:07</td>\n      <td>YYYY一MM一DD HH:MM : ss</td>\n      <td>混合日期和时间值，时间戳</td>\n\t</tr>\n</table>\n\n---\n## 2. 数据库操作\n>注：[ ]内字段可省略\n\n|操作名称|操作命令\n|-|-|\n创建数据库|CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULTCHARSET 字符集] [ COLLATE 排序规则];\n删除数据库|DROP DATABASE [ IF EXISTS]数据库名;\n查询所有数据库|SHOW DATABASES;\n查询当前数据库|SELECT DATABASE();\n使用数据库|USE 数据库名;\n## 3. 表操作\n|操作名称|操作命令\n|-|-|\n查询当前数据库所有表|SHOW TABLES;\n创建表|<br> CREATE TABLE 表名(<br/>  字段1 字段1类型[COMMENT 字段1注释],<br/>  字段2 字段2类型[COMMENT 字段2注释],<br/>  字段3 字段3类型[COMMENT 字段3注释],<br/>  ...<br/>  字段n 字段n类型[COMMENT 字段n注释]<br/>)[COMMENT 表注释];<br>\n查询表结构|DESC 表名;\n删除表|DROP TABLE [IF EXISTI] 表名;\n查询指定表的建表语句|SHOW CREATE TABLE 表名;\n修改表名|ALTER TABLE 表名RENAME TO新表名;\n添加字段|ALTER TABLE 表名 ADD 字段名 类型(长度)[COMMENT 注释][约束];\n删除字段|ALTER TABLE 表名 DROP 字段名;\n修改数据类型|ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);\n修改字段名和字段类型|ALTERTABLE 表名 CHANGE 旧字段名 新字段名类型(长度) [COMMENT注释] [约束];","tags":["MySQL"],"categories":["MySQL"]},{"title":"QML学习笔记(十一)","url":"/2023/05/11/QML/QML学习笔记(十一)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n\n## MouseArea\n### 一、描述\n>","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(十)","url":"/2023/05/11/QML/QML学习笔记(十)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n\n## Loader\n### 一、描述\n>Loader用于动态加载QML组件。\n>加载器可以加载QML文件（使用source属性）或Component对象（使用sourceComponent属性）。它有助于将组件的创建延迟到需要时：例如，应该根据需要创建组件时，或者出于性能原因不应该不必要地创建组件时。  \n\n {% note green 'fa-regular fa-hand-point-down' %}\n\n下面是加载“Page1”的Loader。当单击MouseArea时，将其作为组件:\n\n{% endnote %}\n```QML\n import QtQuick 2.0\n\n Item {\n     width: 200; height: 200\n\n     Loader { id: pageLoader }\n\n     MouseArea {\n         anchors.fill: parent\n         onClicked: pageLoader.source = \"Page1.qml\"\n     }\n }\n```\n{% note green 'fa-regular fa-hand-point-up' %}\n\n可以使用item属性访问加载的对象。\n如果源或sourceComponent发生变化，任何先前实例化的项都会被销毁。将source设置为空字符串或将sourceComponent设置为undefined会破坏当前加载的对象，释放资源并使Loader为空。\n\n{% endnote %}\n### 二、加载程序大小调整行为\n\n>如果源组件不是Item类型，则Loader不会应用任何特殊的大小规则。当用于加载可视类型  >时，Loader应用以下大小规则:\n- 如果未为Loader指定显式大小，则加载组件后，Loader会自动调整为已加载项的大小。\n- 如果加载器的大小是通过设置宽度、高度或锚定来显式指定的，则加载的项目将被调整为加载器的大小。  \n\n{% note green 'fa-regular fa-hand-point-down'%}\n\n在这两种情况下，项目和Loader的大小是相同的。这确保了对Loader的锚定等同于对加载项的锚定。\n\n{% endnote %}\n\n```QML\nsizeloader.qml\n import QtQuick 2.0\n\n Item {\n   width: 200; height: 200\n\n   Loader {\n     // Explicitly set the size of the\n     // Loader to the parent item's size\n     anchors.fill: parent\n     sourceComponent: rect\n   }\n\n   Component {\n     id: rect\n     Rectangle {\n       width: 50\n       height: 50\n       color: \"red\"\n       }\n   }\n }\n```\n{% note green 'fa-regular fa-hand-point-up'%}\n\n红色矩形将调整为根项的大小。\n\n{% endnote %}\n\n```QML\nsizeitem.qml\n import QtQuick 2.0\n\n Item {\n   width: 200; height: 200\n\n   Loader {\n     // position the Loader in the center\n     // of the parent\n     anchors.centerIn: parent\n     sourceComponent: rect\n   }\n\n   Component {\n       id: rect\n       Rectangle {\n           width: 50\n           height: 50\n           color: \"red\"\n       }\n   }\n }\n```\n{% note green 'fa-regular fa-hand-point-up'%}\n\n红色矩形将是50x50，居中于根项。\n\n{% endnote %}\n### 三、从加载对象接收信号\n{% note green 'fa-regular fa-hand-point-down'%}\n\n从加载对象发出的任何信号都可以使用Connections类型接收。  \n例如，下面的应用程序。qml加载MyItem。qml，并且能够通过Connections对象接收来自加载项的消息信号:\n\n{% endnote %}\n\n```QML\napplication.qml\n import QtQuick 2.0\n\n Item {\n     width: 100; height: 100\n\n     Loader {\n        id: myLoader\n        source: \"MyItem.qml\"\n     }\n\n     Connections {\n         target: myLoader.item\n         onMessage: console.log(msg)\n     }\n }\n```\n```QML\nMyItem.qml\n import QtQuick 2.0\n\n Rectangle {\n    id: myItem\n    signal message(string msg)\n\n    width: 100; height: 100\n\n    MouseArea {\n        anchors.fill: parent\n        onClicked: myItem.message(\"clicked!\")\n    }\n }\n```\n{% note green 'fa-regular fa-hand-point-up'%}\n\n或者，自从MyItem。qml是在Loader的作用域中加载的，它也可以直接调用Loader或它的父Item中定义的任何函数。\n\n{% endnote %}\n### 四、焦点和关键事件\n>Loader是一个焦点作用域。它的任何子焦点必须将其focus属性设置为true才能获得活动焦点。(请参阅Qt Quick中的键盘焦点了解更多细节。)在加载项中接收到的任何关键事件也应该被接受，这样它们就不会传播到Loader。\n\n{% note green 'fa-regular fa-hand-point-down'%}\n例如，下面的应用程序。qml加载KeyReader。当鼠标区域被点击时。注意，对于Loader和动态加载对象中的Item, focus属性都被设置为true:\n{% endnote %}\n\n```QML\n\napplication.qml\n import QtQuick 2.0\n\n Rectangle {\n     width: 200; height: 200\n\n     Loader {\n         id: loader\n         focus: true\n     }\n\n     MouseArea {\n         anchors.fill: parent\n         onClicked: {\n             loader.source = \"KeyReader.qml\"\n         }\n     }\n\n     Keys.onPressed: {\n         console.log(\"Captured:\",\n                     event.text);\n     }\n }\n```\n```QML\nKeyReader.qml\n import QtQuick 2.0\n\n Item {\n     Item {\n         focus: true\n         Keys.onPressed: {\n             console.log(\"KeyReader captured:\",\n                         event.text);\n             event.accepted = true;\n         }\n     }\n }\n```\n\n{% note green 'fa-regular fa-hand-point-up'%}\n一旦KeyReader。加载QML后，它接受键事件并设置事件。接受为true，这样事件就不会传播到父矩形。  \n从QtQuick 2.0开始，Loader也可以加载非可视化组件。\n{% endnote %}\n\n### 五、未完待续","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"兔年元旦","url":"/2022/12/31/洋芋加糖/2023-01-01/","content":"<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/鱼酷合照.jpg\" alt=\"今年最后的合照\" width=\"200\"  align=\"bottom\" />  \n\n　　今年最后的合照我居然没有原图呀宝贝❤️  \n　　宝贝，虎年过去了，迎来了我们的本命年，兔兔🐇年了，宝贝新年快乐哦❤️  \n　　这一年过的好快呀，尤其是下半年呀，感觉不到的呢就过去了，和宝宝在一起时间就是过的非常快呢❤️  \n　　2022年对宝贝来说是的非常重要的一年呢，这一年在宝宝身上发生了好多的事情，年初宝贝在紧张的心情下取得了优异的成绩\n  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/激动1.png\" alt=\"激动\" width=\"150\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/考研成绩.png\" alt=\"宝贝优秀的成绩\" width=\"200\"  align=\"bottom\" />\n　　考了好成绩的宝贝也带着胜利的喜讯来青岛度假，来陪我了，我们终于一起喂了海鸥，去了湛山寺祈福，去了大学路打卡\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/举杯庆祝.jpg\" alt=\"举杯庆祝\" width=\"200\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/七个葫芦娃.png\" alt=\"偶遇兄弟们\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/宝贝喂海鸥.png\" alt=\"喂海鸥\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/大学路.png\" alt=\"宝宝真美\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-1.png\" alt=\"杨大胆欺负宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-2.png\" alt=\"我拍的真好看\" width=\"400\"  align=\"bottom\" />\n　　然后就又开始了漫长的，为期6个月的网恋，在这6个月里宝宝还去做了辛勤的园丁，成为了熏老师  \n　　随之到了9月，宝宝该开学了，宝宝要来青岛了，终于能和宝宝长时间的在一起了\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-3.png\" alt=\"好看的天和幸福的我们\" width=\"400\"  align=\"bottom\" />\n　　宝宝刚开学就被囚禁了，只能隔着栏杆探监宝贝，铁窗泪啊😭\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-4.png\" alt=\"短短的探监\" width=\"400\"  align=\"bottom\" />\n　　我们的第一次约会，宝宝迟到了好久，但是，宝宝超美！！！😍\n　　但是。。。不得不说我的拍照技术属实有点烂，我居然选不出照片来😭\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-5.png\" alt=\"超美的宝宝\" height=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-6.png\" alt=\"宝宝耳钉真好看\" height=\"400\"  align=\"bottom\" />\n　　宝宝嫌俺胡子扎人，给俺买了刮胡刀❤️\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-7.png\" alt=\"用宝宝给买的刮胡刀剃的胡子真干净\" height=\"400\"  align=\"bottom\" />\n　　和宝宝约会，约会，又约会，要和宝宝天天约会，呕吼😍  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-8.png\" alt=\"正在摆造型的宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-9.png\" alt=\"有好看丸子头的宝宝\" width=\"200\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-10.png\" alt=\"为数不多的拍的好看的照片\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-11.png\" alt=\"第二为数不多的拍的好看的照片\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-12.png\" alt=\"两张占满屏幕的大脸\" width=\"400\"  align=\"bottom\" />\n　　第二次探监😭  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-13.png\" alt=\"爱吃巧克力的宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-14.png\" alt=\"呲牙喜的俩人\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-15.png\" alt=\"铁窗泪-第二部\" width=\"400\"  align=\"bottom\" />\n　　宝宝生日要到了🎂\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-21.png\" alt=\"送给宝宝的油条花\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-16.png\" alt=\"捡叶叶\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-17.png\" alt=\"蝴蝶蝶\" width=\"400\"  align=\"bottom\" />\n　　可是没有成品照片唉  \n\n　　宝宝生日快乐🎂\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-18.png\" alt=\"许愿的宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-19.png\" alt=\"好看的宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-20.png\" alt=\"仙女宝宝\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-22.png\" alt=\"宝宝的花花和我\" width=\"400\"  align=\"bottom\" />\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-23.png\" alt=\"宝宝的簪子\" width=\"400\"  align=\"bottom\" />\n　　接着约会约会🥰\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-24.png\" alt=\"宝宝带我吃鸡爪\" width=\"400\"  align=\"bottom\" />  \n　　宝宝放假了  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-25.png\" alt=\"宝宝陪我上班\" width=\"400\"  align=\"bottom\" />  \n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-26.png\" alt=\"流氓宝宝\" width=\"400\"  align=\"bottom\" /> \n　　呼应一下开头\n<img src=\"https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/2023-01-01-27.png\" alt=\"最后的鱼\" width=\"400\"  align=\"bottom\" /> \n　　然后宝宝就回家了，我们又分开了，想宝宝了，亲你一口，你没回应，但我还是想你爱你哦。  \n\n　　宝宝，我们的照片好少呀，记录一下还是挺好的呢，都是些美好的回忆呀❤️  \n\n　　宝宝，新的一年快乐，2016快乐，在这里还要向宝宝道歉，我们的2000天纪念日我忘记了，还请宝宝责罚😘  \n\n　　宝宝，新的一年我们还要好好的，我们还要出去玩，去约会，我还会找你约会，去做宝宝学习路上的绊脚石的，老婆我爱你，我爱你哦❤️❤️❤️","tags":["洋芋加糖"],"categories":["洋芋加糖"]},{"title":"74HC595-I/O口扩展芯片","url":"/2022/11/07/单片机/74HC595/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章引用资源：  \n>+ <font color=LightSeaGreen>电子发烧友-**ss**:</font>  https://www.elecfans.com/dianzichangshi/20171208598361.html\n>+ <font color=LightSeaGreen>**74HC595数据手册**:</font>https://www.nexperia.com/products/logic/i-o-expansion-logic/shift-registers/74HC595D.html\n\n{% endnote %}\n\n---\n## 74HC595简介\n　　74HC595是一个8位串行输入、平行输出的位移缓存器：平行输出为三态输出。在SCK的上升沿，单行数据由SDL输人到内部的8位位移缓存器，并由Q7‘输出，而平行输出则是在LCK的上升沿将在8位位移缓存器的数据存人到8位平行输出缓存器。当串行数据输人端OE的控制信号为低使能时，平行输出端的输出值等于平行输出缓存器所存储的值。而当OE为高电位，也就是输出关闭时，平行输出端会维持在高阻抗状态。\n## 74hc595引脚图及功能\n![74HC595引脚图](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/74HC595引脚图.png)\nSymbol|Pin|Description\n|:---:|:---:|:---:|\nQ0-Q7|15,1,2,3,4,5,6,7|8位数据并行输出口\nGND|8|接地\nQ7S|9|串行数据输出，级联时连接下一芯片串行输入(DS)\nMR|10|主复位(低电平有效)，将移位寄存器清零，通常接高电平\nSHCP|11|数据输入时钟线，上升沿时将串行数据右移一位\nSTCP|12|输出寄存器锁存时钟，上升沿时将串行数据移至输出寄存器\nOE|13|输出有效(低电平有效)，通常接低电平\nDS|14|串行数据输入，级联时接上一芯片串行数据输出(Q7S)\nVCC|16|电源\n## 真值表与时序图\n","tags":["单片机","芯片"],"categories":["单片机"]},{"title":"侧边组件实现打开关闭及调整","url":"/2022/08/03/侧边组件/侧边组件实现打开关闭及调整/","content":"`main.qml`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Window 2.14\nimport QtQuick.Controls 1.4\nimport QtQuick.Controls 2.15\n\nWindow {\n    id: mainwindow\n    x: Screen.width-mainwindowSizeW.value\n    y: mainwindowYPos.value\n    width: mainwindowSizeW.value\n    height: mainwindowSizeH.value\n    visible: true\n    flags: Qt.FramelessWindowHint|Qt.Window|Qt.WindowStaysOnTopHint\n    color: \"transparent\"\n    title: qsTr(\"Hello World\")\n\n    Item{\n        anchors.fill: parent\n\n        Rectangle{\n            id:rect1\n            anchors.fill: parent\n            radius: mainwindowRadius.value\n            color: \"red\"        \n        }\n        MouseArea{\n            anchors.fill: rect1\n            hoverEnabled: true\n            onEntered: mywindow.visible = true\n        }\n        Component.onCompleted: {\n\n        }\n        }\n\n    MyWindow{\n        id: setting\n        width: 640\n        height: 480\n        x: Screen.width/2-width/2\n        y: Screen.height/2-height/2\n\n\n        Grid{\n            columns: 2\n            verticalItemAlignment: Grid.AlignVCenter\n            horizontalItemAlignment: Grid.AlignLeft\n            columnSpacing:  100\n            Label{ text: \"触发条位置\" }\n            Slider {\n                id: mainwindowYPos\n                 from: 30\n                 value: Screen.height/2-mainwindowSizeH.value/2\n                 to: Screen.height-mainwindowSizeH.value-30\n             }\n            Label{ text: \"触发条宽度\" }\n            Slider {\n                id: mainwindowSizeW\n                 from: 1\n                 value: 15\n                 to: 30\n             }\n            Label{ text: \"触发条高度\" }\n            Slider {\n                id: mainwindowSizeH\n                 from: 50\n                 value: 125\n                 to: 200\n             }\n            Label{ text: \"触发条圆角\" }\n            Slider {\n                id: mainwindowRadius\n                 from: 1\n                 value: 0\n                 to: mainwindowSizeW.value/2\n             }\n            Label{ text: \"快捷窗口宽度\" }\n            Slider {\n                id: mywindowW\n                 from: 100\n                 value: 400\n                 to: 1000\n             }\n            Label{ text: \"快捷窗口高度\" }\n            Slider {\n                id: mywindowH\n                 from: 100\n                 value: Screen.height-50\n                 to: Screen.height-10\n             }\n            Label{ text: \"快捷窗口位置\" }\n            Slider {\n                id: mywindowX\n                 from: 100\n                 value: mainwindow.x-mywindowW.value-20\n                 to: Screen.width-mywindowW.value\n             }\n            Label{ text: \"快捷窗口圆角\" }\n            Slider {\n                id: mywindowRadius\n                 from: 1\n                 value: 30\n                 to: mywindowW.value/2\n             }\n        }\n    }\n    MyWindow{\n        id: mywindow\n        width: mywindowW.value\n        height: mywindowH.value\n        x: mywindowX.value\n        y: Screen.height/2-mywindowH.value/2-10\n        flags: Qt.FramelessWindowHint|Qt.Widget\n        color: \"transparent\"\n\n        Item{\n            anchors.fill: parent\n\n            Rectangle{\n                id:mainRect\n                anchors.fill: parent\n                color: \"blue\"\n                radius: mywindowRadius.value\n                MouseArea{\n                    anchors.fill: mainRect\n                    hoverEnabled: true\n                    onExited: mywindow.visible = false\n                }\n                Rectangle{\n                    id: settingButton\n                    anchors.right: mainRect.right\n                    anchors.top: mainRect.top\n                    anchors.margins: 10\n                    width: 50\n                    height: 50\n\n                    MouseArea{\n                        anchors.fill: settingButton\n                        onClicked: setting.visible = true\n                    }\n                }\n            }\n        }\n\n    }\n}\n```\n`MyWindow.qml`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Controls 1.4\nimport QtQuick.Window 2.14\n\nWindow {\n}\n\n```\n实现效果\n![侧边组件实现打开关闭及调整](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/侧边组件实现打开关闭及调整.gif)\n","tags":["Qt","QML","笔记","侧边组件"],"categories":["Qt"]},{"title":"QML学习笔记(九)","url":"/2022/08/02/QML/QML学习笔记(九)/","content":"## Setting\n### 一、描述\n>Settings类型提供持久的与平台无关的应用程序设置。  \n>注意:此类型是通过导入Qt.labs.settings模块提供的。实验室模块中的类型不保证在未来的版本中保持兼容。 \n> \n>用户通常希望应用程序能够跨会话记住它的设置(窗口大小和位置，选项等)。设置类型使您能够以最少的工作量保存和恢复此类应用程序设置。  \n>通过在Settings元素中声明属性来指定各个设置值。支持所有基本类型属性。推荐的方法是使用属性别名，以便以两种方式自动更新属性。下面的示例显示如何使用“设置”存储和恢复窗口的几何图形。  \n```QML\nimport QtQuick.Window 2.1\n import Qt.labs.settings 1.0\n\n Window {\n     id: window\n\n     width: 800\n     height: 600\n\n     Settings {\n         property alias x: window.x\n         property alias y: window.y\n         property alias width: window.width\n         property alias height: window.height\n     }\n }\n\n```\n>在应用程序第一次启动时，窗口获得指定为800x600的默认尺寸。注意，没有指定默认位置—我们让窗口管理器处理它。稍后，当窗口几何形状更改时，新值将自动存储到持久设置中。第二次运行的应用程序将从持久设置中获得初始值，使窗口恢复到以前的位置和大小。  \n>通过使用属性别名来实现完全声明式语法，代价是在别名属性的值发生更改时存储持久设置。普通属性可用于对存储持久设置进行更细粒度的控制。下面的例子演示了如何保存组件销毁的设置。  \n```QML\nimport QtQuick 2.1\n import Qt.labs.settings 1.0\n\n Item {\n     id: page\n\n     state: settings.state\n\n     states: [\n         State {\n             name: \"active\"\n             // ...\n         },\n         State {\n             name: \"inactive\"\n             // ...\n         }\n     ]\n\n     Settings {\n         id: settings\n         property string state: \"active\"\n     }\n\n     Component.onDestruction: {\n         settings.state = page.state\n     }\n }\n```\n>注意现在如何在持久设置属性中指定默认值，并将实际属性绑定到该设置，以便从持久设置获得初始值。\n\n### 二、应用识别符\n>通过提供应用程序名称、组织和域或指定fileName来标识特定于应用程序的设置。\n```QML\n #include <QGuiApplication>\n #include <QQmlApplicationEngine>\n\n int main(int argc, char *argv[])\n {\n     QGuiApplication app(argc, argv);\n     app.setOrganizationName(\"Some Company\");\n     app.setOrganizationDomain(\"somecompany.com\");\n     app.setApplicationName(\"Amazing Application\");\n\n     QQmlApplicationEngine engine(\"main.qml\");\n     return app.exec();\n }\n```\n> 这些通常在c++中main()的开头指定，但也可以通过以下属性在QML中控制:\n>+ Qt.application.name,\n>+ Qt.application.organization\n>+ Qt.application.domain。\n \n ### 三、类\n>通过类别属性指定类别名称，可以将应用程序设置划分为逻辑类别。使用逻辑分类不仅可以提供更清晰的设置结构，还可以防止设置键之间可能的冲突。  \n>如果需要多个类别，使用多个设置对象，每个对象都有自己的类别:\n```QML\nItem {\n     id: panel\n\n     visible: true\n\n     Settings {\n         category: \"OutputPanel\"\n         property alias visible: panel.visible\n         // ...\n     }\n\n     Settings {\n         category: \"General\"\n         property alias fontSize: fontSizeSpinBox.value\n         // ...\n     }\n }\n```\n>不用确保应用程序中的所有设置都有唯一的名称，设置可以划分为唯一的类别，然后这些类别可能包含使用其他类别中使用的相同名称的设置——而不会产生冲突。\n\n### 四、注意事项\n>当前的实现基于QSettings。这就增加了某些限制，例如缺少变更通知。使用一个设置实例写入设置值不会更新另一个设置实例中的值，即使它们引用同一类别中的相同设置。  \n>信息存储在Windows上的系统注册表中，存储在macOS上的XML首选项文件中。在其他Unix系统中，如果没有标准，则使用INI文本文件。更多细节请参阅QSettings文档。\n### 五、属性\n\n1. `category` : string\n>此属性保存设置类别的名称。  \n>类别可用于将相关设置分组在一起。\n\n2. `fileName` : string\n>此属性保存设置文件的路径。如果该文件不存在，则创建该文件。  \n这个属性是在Qt 5.12中引入的。\n\n### 六、方法\n\n1. setValue(string key, var value)\n>将设置键的值设置为value。如果该键已经存在，则覆盖之前的值。  \n该方法在Qt 5.12中被引入。\n\n2. sync()\n>将任何未保存的更改写入永久存储，并重新加载同时被另一个应用程序更改的任何设置。  \n这个函数会从QSettings的析构函数中自动调用，并由事件循环定期调用，所以您通常不需要自己调用它。\n\n3. var value(string key, var defaultValue)\n> 返回设置键的值。如果该设置不存在，则返回defaultValue。  \n该方法在Qt 5.12中被引入。","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(八)","url":"/2022/08/01/QML/QML学习笔记(八)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## 自定义QML组件\n\n新建QML文件-`TimerDateLabel.qml`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Controls 1.4\n\nLabel {\n    id:label\n    Timer {\n        interval: 500; running: true; repeat: true\n        onTriggered: label.text = Date().toString()\n    }\n}\n```\n在`main.qml`中调用`TimerDateLabel.qml`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Window 2.14\nimport QtQuick.Controls 1.4\n\nWindow {\n    width: 640\n    height: 480\n    visible: true\n    title: qsTr(\"Hello World\")\n\n    Item{\n        anchors.fill: parent\n\n        Column{\n            TimerDateLable{\n              color: \"red\"\n            }\n            TimerDateLable{\n              color: \"blue\n            }\n    }\n\n}\n}\n```\n![QML自定义组件](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/QML自定义组件.png)\n\n\n\n","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(七)","url":"/2022/08/01/QML/QML学习笔记(七)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## Timer\n### 一、描述\n计时器可以用来触发一次动作，也可以在给定的时间间隔内重复触发。  \n\n这是一个显示当前日期和时间的计时器，每500毫秒更新一次文本。它使用JavaScript Date对象来访问当前时间。\n```QML\n import QtQuick 2.0\n\n Item {\n     Timer {\n         interval: 500; running: true; repeat: true\n         onTriggered: time.text = Date().toString()\n     }\n\n     Text { id: time }\n }\n```\n![Timer](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Timer.png)  \nTimer类型与动画计时器同步。因为动画计时器通常设置为60fps，所以计时器的分辨率最多为16ms。  \n如果Timer正在运行，并且它的一个属性被更改，运行时间将被重置。例如，如果一个间隔为1000ms的Timer在启动后500ms改变了它的repeat属性，那么运行时间将被重置为0，并在1000ms后触发Timer。\n### 二、属性\n1. `interval` : int\n>设置触发器之间的间隔，以毫秒为单位。  \n>缺省值是1000毫秒。  \n\n2. `repeat` : bool\n>如果repeat为真，则计时器在指定的时间间隔内重复触发;否则，计时器将在指定的时间间隔触发一次，然后停止(即运行将被设置为`false`)。  \n>重复默认值为`false`。\n\n3. `running` : bool\n>如果设置为`true`，启动计时器;否则将停止定时器。对于非重复计时器，在计时器被触发后，运行设置为`false`。  \n>`Running`默认为`false`。\n\n4. triggeredOnStart : bool\n>当计时器启动时，第一个触发器通常是在指定的时间间隔过后。有时希望在计时器启动时立即触发;例如，建立一个初始状态。  \n>如果triggeredOnStart为true，则计时器在启动时立即触发，然后按指定的间隔触发。注意，如果repeat被设置为false，计时器会被触发两次;一次开始，一次在间歇。  \n>triggeredOnStart默认为false。\n\n### 三、信号\n1. triggered()\n>该信号在Timer超时时发出。  \n>注意:对应的处理程序是onTriggered。\n\n### 四、方法\n1. restart()\n>重新启动定时器  \n>如果Timer没有运行它将被启动，否则它将被停止，重置为初始状态并启动。在调用restart()之后，running属性将为true。\n\n2. start()\n>启动定时器  \n>如果计时器已经在运行，调用此方法将不起作用。在调用start()之后，running属性将为true。\n\n3. stop()\n>停止计时器  \n>如果计时器未运行，调用此方法将不起作用。在调用stop()之后，running属性将为false。\n\n\n\n\n\n","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(六)","url":"/2022/07/28/QML/QML学习笔记(六)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## ApplicationWindow\n### 一、描述\nApplicationWindow是一个窗口，增加了方便的定位项目，如菜单栏，工具栏和状态栏，以平台独立的方式。\n![ApplicationWindow](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/ApplicationWindow.png)  \n注意:默认情况下，ApplicationWindow是不可见的。\n### 二、属性\n1. `contentItem` : ContentItem\n>该组保存内容项的大小限制。这是工具栏和状态栏之间的区域。当计算实际窗口的有效大小约束时，`ApplicationWindow`将使用这个作为输入。它拥有以下6个属性，用于描述最小、隐式和最大尺寸:  \n\n分组属性|描述\n|-|-|\ncontentItem.minimumWidth|内容项的最小宽度。\ncontentItem.minimumHeight|内容项的最小高度。\ncontentItem.implicitWidth|内容项的隐式宽度。\ncontentItem.implicitHeight|内容项的隐式高度。\ncontentItem.maximumWidth|内容项的最大宽度。\ncontentItem.maximumHeight|内容项的最大高度。\n\n2. `menuBar` : MenuBar\n>这个属性保存菜单栏。  \n>缺省情况下，不设置此值。  \n\n3. `statusBar` : Item\n>此属性保存状态栏Item。  \n>它可以设置为任何Item类型，但通常与StatusBar一起使用。  \n>缺省情况下，不设置此值。当您设置状态栏项时，它将自动锚定到应用程序窗口中。  \n\n4. `style` : Component\n>窗口的样式组件。  \n\n5. `toolBar` : Item\n>此属性保存工具栏项目。  \n>它可以设置为任何Item类型，但通常与ToolBar一起使用。  \n>缺省情况下，不设置此值。当您设置工具栏项时，它将自动锚定到应用程序窗口中。\n\n### 三、示例\n```QML\nimport QtQuick 2.14\nimport QtQuick.Controls 1.4\nimport QtQuick.Layouts 1.15\n\nApplicationWindow {\n    id : window\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n    \n    minimumWidth:200          //窗口宽度最大值\n    minimumHeight:200         //窗口高度最大值\n    maximumWidth:300          //窗口宽度最小值\n    maximumHeight:300         //窗口宽度最小值\n\n    menuBar: MenuBar {        //菜单栏\n        Menu {                //菜单\n            title: \"File\"     //菜单标题\n            MenuItem { text: \"Open...\" }  //子菜单\n            MenuItem { text: \"Close\" }    //子菜单\n        }    \n        Menu {\n            title: \"Edit\"\n            MenuItem { text: \"Cut\" }\n            MenuItem { text: \"Copy\" }\n            MenuItem { text: \"Paste\" }\n            }\n         }\n    statusBar: StatusBar {    //状态栏\n        RowLayout {           //排列\n            anchors.fill: parent\n            Label { text: \"Read Only\" }\n              }\n         }\n    toolBar:ToolBar {         //工具栏\n         RowLayout {\n             anchors.fill: parent\n             ToolButton {     //工具按钮\n                 text: \"one\"\n             }\n             ToolButton {\n                 text: \"two\"\n             }\n             ToolButton {\n                 text: \"there\"\n             }\n             Item { Layout.fillWidth: true }\n             CheckBox {       //多选按钮\n                 text: \"Enabled\"\n                 checked: true\n                 Layout.alignment: Qt.AlignRight\n             }\n             }\n         }\n    \n        Rectangle{          //正方形,填充在内容区\n            anchors.fill: parent\n            color: \"blue\"\n        }\n        \n        style:Component {   //风格化设置\n                 id: redSquare\n\n                 Rectangle {\n                     color: \"red\"\n                     width: 10\n                     height: 10\n                 }\n             }\n\n         Loader { sourceComponent: redSquare }    //加载具体实例\n         Loader { sourceComponent: redSquare; x: 20 }\n}\n```\n![ApplicationWindow示例](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/ApplicationWindow示例.png)\n## 附加信号及附加属性\n可以附加在其他元素上的属性和信号\n### 附加信号(Attached Signals)\n以 `destruction` 的附加信号为例\n1. complted()\n>在对象实例化后触发。一旦建立了完整的QML环境，这可以用于在启动时执行脚本代码  \n>onCompleted信号处理程序可以在任何对象上声明。未定义运行处理程序的顺序。  \n>注意:相应的处理程序是`completed.onCompleted:{  }\n`\n\n2. destruction()\n>当对象开始销毁时发出。这可用于撤消响应`completed()`信号所做的工作，或应用程序中的其他命令性代码。  \n>ondestroy信号处理程序可以在任何对象上声明。未定义运行处理程序的顺序。  \n>注意:对应的处理程序是 `completed.onDestruction:{  }`\n\n```QML\nWindow {\n    id : window\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n   Component.onCompleted:{\n       console.log(\"window 构造完成\")\n   }\n   Component.onDestruction:{\n       console.log(\"window 析构完成\")\n   }\n   Rectangle{\n       anchors.fill: parent\n       color: \"red\"\n\n       Component.onCompleted:{\n           console.log(\"Rectangle 构造完成\")\n       }\n       Component.onDestruction:{\n           console.log(\"Rectangle 析构完成\")\n       }\n   }\n}\n```\n![附加信号](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/附加信号.png)\n### 附加属性\n以 `ScrollBar` 附加属性为例\n1. void decrease()\n\n\n","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(五)","url":"/2022/07/25/QML/QML学习笔记(五)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## CheckBox\n### 一、描述\nCheckBox 提供了复选框按钮，可以打开（选中）或关闭（未选中）。复选框通常用于从一组选项中选择一个或多个选项。对于更大的选项集，例如列表中的选项，请考虑改用 `CheckDelegate`。\n\n默认只有选中和未选中状态,除此之外，还有第三种状态：部分选中。可以使用 `tristate` 属性启用部分选中状态。\n### 二、属性成员\n1. `checkState` : enumeration\n> 复选框的选中状态。\n>+ Qt.Unchecked：未选中。\n>+ Qt.PartiallyChecked：部分选中。仅在启用三态时使用。\n>+ Qt.Checked：已选中。\n\n1. `nextCheckState` : function\n> 此属性包含一个回调函数，每当用户通过触摸、鼠标或键盘交互切换复选框时，都会调用该函数以**确定下一个选中状态**。\n> \n> 默认情况下，普通复选框在 `Qt.Unchecked` 和 `Qt.Checked` 状态之间循环，三态复选框在 `Qt.Unchecked`、`Qt.PartiallyChecked` 和 `Qt.Checked` 状态之间循环。\n### 三、CheckBox示例\n```QML\nimport QtQuick\nimport QtQuick.Controls\n \nWindow {\n    width: 640\n    height: 480\n    visible: true\n    title: qsTr(\"Hello World\")\n \n    CheckBox {\n        id: control\n        text: qsTr(\"CheckBox\")\n        checked: true\n        hoverEnabled: false\n \n        indicator: Rectangle {\n            implicitWidth: 26\n            implicitHeight: 26\n            x: control.leftPadding\n            y: parent.height / 2 - height / 2\n            radius: 3\n            border.color: control.down ? \"#17a81a\" : \"#21be2b\"\n \n            Rectangle {\n                width: 14\n                height: 14\n                x: 6\n                y: 6\n                radius: 2\n                color: control.down ? \"#17a81a\" : \"#21be2b\"\n                visible: control.checked\n            }\n        }\n \n        contentItem: Text {\n            text: control.text\n            font: control.font\n            opacity: enabled ? 1.0 : 0.3\n            color: control.down ? \"#17a81a\" : \"#21be2b\"\n            verticalAlignment: Text.AlignVCenter\n            leftPadding: control.indicator.width + control.spacing\n        }\n    }\n}\n```\n![CheckBox示例](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/CheckBox示例.gif)\n## ComboBox\n### 一、描述\n组合框是一个组合按钮和弹出列表。它提供了一种以占用最少屏幕空间的方式向用户呈现选项列表的方法。\nComboBox是用数据模型填充的。数据模型通常是JavaScript数组、ListModel或整数，但也支持其他类型的数据模型。\n### 二、属性成员\n1. `acceptableInput` : bool\n> 此属性保存组合框是否在可编辑文本字段中包含可接受的文本。  \n> 如果已经设置了验证器，只有当验证器接受当前文本作为最终字符串(而不是中间字符串)时，该值才为true。  \n\n2. **[read-only]** `count` : int\n> 此属性保存组合框中的项数。\n\n3. `currentIndex` : int\n> 此属性保存组合框中当前项的索引。  \n> 当count为0时，默认值为-1，否则为0。\n4. **[read-only]** `currentText` : string\n>此属性保存组合框中当前项的文本。\n5. **[read-only]** `currentValue` : string\n>此属性保存组合框中当前项的值。\n6. `delegate` : Component\n>此属性保存一个委托，该委托在弹出的组合框中显示项。  \n>建议使用ItemDelegate(或任何其他AbstractButton派生)作为委托。这确保了交互按预期工作，并且弹出窗口将在适当的时候自动关闭。当使用其他类型作为委托时，必须手动关闭弹出窗口。\n7. `displayText` : string\n>此属性保存组合框按钮上显示的文本。  \n>默认情况下，显示文本显示当前所选内容。也就是说，它在当前项目的文本之后。但是，可以使用自定义值重写默认的显示文本。\n```QML\nComboBox {\n            currentIndex: 1\n            displayText: \"Size: \" + currentText\n            model: [\"S\", \"M\", \"L\"]\n        }\n```\n![ComboBox-displayText属性](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/ComboBox-displayText属性.png)   \n8. `down` : bool\n>该属性保存组合框按钮在视觉上是否向下。  \n>除非显式设置，否则该属性在按下或弹出时为真。可见是真的。若要返回默认值，请将此属性设置为undefined。\n9. `editText` : string\n>此属性将文本保存在可编辑组合框的文本字段中。\n10. `editable` : bool\n>此属性保存组合框是否可编辑。  \n>默认值为false。\n11. `flat` : bool\n>该属性保存组合框按钮是否为平面。  \n>\n>平面组合框按钮不会绘制背景，除非与之交互。与普通的组合框相比，扁平的组合框提供的外观让它们在UI的其他部分中不那么显眼。例如，当将组合框放置到工具栏中时，可能需要将组合框做成扁平的，以便它与工具按钮的扁平外观更好地匹配。 \n>\n>默认值为false。\n12. **[read-only]** `highlightedIndex` : int\n>此属性保存组合框弹出列表中突出显示项的索引。  \n>当一个高亮显示的项被激活时，弹出窗口关闭，currentIndex被设置为highlightedIndex，并且这个属性的值被重置为-1，因为不再有高亮显示的项。\n13. **[read-only]** `implicitIndicatorHeight` : real\n>此属性保存隐式指示符高度。  \n>值等于indicator ? indicator.implicitHeight : 0.  \n>这通常与implicitcontenttheight和implicitBackgroundHeight一起使用来计算implicitHeight。\n14. **[read-only]** `implicitIndicatorWidth` : real\n>此属性保存隐式指示符宽度。  \n>值等于indicator ? indicator.implicitWidth : 0.  \n>这通常与implicitContentWidth和implicitBackgroundWidth一起使用来计算implicitWidth。\n15. `indicator` : Item\n>此属性保存删除指示器项。\n16. **[read-only]** inputMethodComposing : bool\n>此属性保存可编辑组合框是否具有来自输入法的部分文本输入。  \n>在组合时，输入法可能依赖组合框中的鼠标或键事件来编辑或提交部分文本。此属性可用于确定何时禁用可能干扰输入法正确操作的事件处理程序。\n17. `inputMethodHints` : flags\n>为输入法提供有关组合框的预期内容以及应该如何操作的提示。  \n>The default value is Qt.ImhNoPredictiveText.  \n>该值是标志的按位组合，如果没有设置提示，则为Qt.ImhNone。  \n>改变行为的标志有:  \n>+ `imhhiddentext` -字符应该被隐藏，因为通常在输入密码时使用。  \n>+ `imhsensitivedata` -键入的文本不应该被活动输入法存储在任何持久存储，如预测性用户字典。  \n>+ `imhnoautouppercase` -输入法不应该试图在句子结束时自动切换到大写。  \n>+ `Qt.ImhPreferNumbers`—首选编号(但不是必需的)。\n>+ `Qt.ImhPreferNumbers`—首选编号(但不是必需的)。\n>+ `Qt.ImhPreferUppercase`—大写字母首选(但不是必需的)。\n>+ `Qt.Imhprefer`-小写-首选小写字母(但不是必需的)。\n>+ `Qt.Imhnopredictivetext` -在输入时不要使用预测文本(即字典查找)。\n>+ `Qt.Imhdate`—文本编辑器的作用是作为一个日期字段。\n>+ `Qt.ImhTime` -文本编辑器的作用是时间字段。    \n> 限制输入的标志(独占标志)有:\n>+ `Qt.ImhDigitsOnly` -只允许输入数字。\n>+ `Qt.ImhFormattedNumbersOnly` -只允许输入数字。这包括小数点和负号。\n>+ `Qt.ImhUppercaseOnly` -只允许大写字母输入。\n>+ `Qt.ImhLowercaseOnly `-只允许小写字母输入。\n>+ `Qt.ImhDialableCharactersOnly` -只允许使用适合电话拨号的字符。\n>+ `Qt.ImhEmailCharactersOnly` -只允许适用于电子邮件地址的字符。\n>+ `Qt.ImhUrlCharactersOnly` -只允许与url匹配的字符。  \n> 面具:\n>+ `Imhexclusiveinputmask——如果使用了任何独占标志，则此掩码生成非零。`\n18. `model` : model\n> 此属性保存为组合框提供数据的模型。\n```QML\nComboBox {\n     textRole: \"key\"\n     model: ListModel {\n         ListElement { key: \"First\"; value: 123 }\n         ListElement { key: \"Second\"; value: 456 }\n         ListElement { key: \"Third\"; value: 789 }\n     }\n }\n```\n19. `popup` : Popup\n> 此属性保存弹出窗口。  \n> 如果需要，可以手动打开或关闭弹出窗口:\n>+ onSpecialEvent: comboBox.popup.close()\n20. `pressed` : bool\n>该属性保存组合框按钮是否被物理按下。按钮可以通过触摸或按键事件来按下。\n21. `selectTextByMouse` : bool\n>此属性保存是否可以用鼠标选择可编辑组合框的文本字段。  \n>`默认值为false。`\n22. `textRole` : string\n>此属性保存用于填充组合框的模型角色。  \n>当模型有多个角色时，可以通过设置textRole来确定应该显示哪个角色。\n23. `validator` : Validator\n>此属性保存可编辑组合框的输入文本验证器。  \n>当设置验证器时，文本字段将只接受使文本属性处于中间状态的输入。只有当按下回车键或回车键时文本处于可接受状态时，才会发出可接受的信号。  \n>目前支持的验证器是IntValidator、DoubleValidator和RegExpValidator。下面是一个使用验证器的例子，它允许在文本字段中输入0到10之间的整数:\n```QML\n ComboBox {\n     model: 10\n     editable: true\n     validator: IntValidator {\n         top: 9\n         bottom: 0\n     }\n }\n```\n24. `valueRole` : string\n>此属性保存模型角色，用于存储与模型中每个项关联的值。\n### 信号函数\n1. void accepted()\n>当按下可编辑组合框上的Return或Enter键时，会发出此信号。  \n>您可以处理这个信号，以便将新输入的项添加到模型中，例如:\n```QML\n ComboBox {\n     editable: true\n     model: ListModel {\n         id: model\n         ListElement { text: \"Banana\" }\n         ListElement { text: \"Apple\" }\n         ListElement { text: \"Coconut\" }\n     }\n     onAccepted: {\n         if (find(editText) === -1)\n             model.append({text: editText})\n     }\n }\n```\n![ComboBox-Accepted信号](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/ComboBox-Accepted信号.png)\n\n>在发出信号之前，将进行检查，以确定该字符串是否存在于模型中。如果是，currentIndex将被设置为它的索引，currentText将被设置为字符串本身。  \n>在发出信号之后，如果第一次检查失败(也就是说，项目不存在)，将进行另一次检查，以查看项目是否由信号处理程序添加。如果是，则相应地更新currentIndex和currentText。否则，它们将分别被设置为-1和“”。  \n>注意:如果组合框上设置了验证器，则只有在输入处于可接受状态时才会发出信号。  \n>注意:对应的处理程序是onAccepted。  \n\n2. void activated(int index)\n>当索引项被用户激活时，会发出此信号。  \n>当一个项目被选中时，弹出窗口是打开的，它会被激活，导致弹出窗口关闭(currentIndex会改变)，或者当弹出窗口关闭时，通过键盘导航组合框，导致currentIndex改变。设置currentIndex属性为index。  \n>注意:对应的处理程序是onActivated。  \n\n3. void highlighted(int index)\n>当用户突出显示弹出列表中索引处的项时，会发出此信号。  \n>高亮显示的信号只在弹出窗口打开和项目高亮显示时发出，但不一定激活。  \n>注意:相应的处理程序是onhighlight。\n### 三、方法函数\n1. void decrementCurrentIndex()\n> 减少组合框的当前索引，或者如果弹出列表可见，则减少突出显示的索引。\n2. int find(string text, enumeration flags)\n>返回指定文本的索引，如果没有找到匹配，则返回-1。  \n>执行搜索的方式由指定的匹配标志定义。默认情况下，组合框执行区分大小写的精确匹配(Qt.MatchExactly)。所有其他匹配类型都不区分大小写，除非还指定了`qt.MatchCasesSensitive`标志。  \n\n|常数|描述|\n|-|-|\n|Qt.MatchExactly|搜索词完全匹配(默认)。\nQt.MatchRegExp|搜索词以正则表达式的形式匹配。\nQt.MatchWildcard|搜索词使用通配符进行匹配。\nQt.MatchFixedString|搜索词匹配为一个固定的字符串。\nQt.MatchStartsWith|搜索词与条目的开始部分匹配。\nQt.MatchEndsWidth|搜索词与条目的结尾匹配。\nQt.MatchContains|搜索项包含在项目中。\nQt.MatchCaseSensitive|搜索是区分大小写的。\n\n3. void incrementCurrentIndex()\n>增加组合框的当前索引，或者如果弹出列表可见，则增加突出显示的索引。\n\n4. int indexOfValue(object value)\n>返回指定值的索引，如果没有找到匹配，则返回-1。  \n>有关如何使用此方法的示例，请参阅组合框模型角色。\n\n5. void selectAll()\n>选择组合框的可编辑文本字段中的所有文本。\n\n6. string textAt(int index)\n>返回指定索引的文本，如果索引出界，则返回空字符串。","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(四)","url":"/2022/07/24/QML/QML学习笔记(四)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## Qt中的基本类型\n### 基本类型如下表\n|类型|含义|\n|:---:|:---|\n|bool|二进制true / false值|\n|double|带有小数点的数字，以双精度存储|\n|enumeration|命名的枚举值|\n|int|整数，如0、10或-20|\n|list|QML对象列表|\n|real|带小数点的数|\n|string|自由格式的文本字符串|\n|url|资源定位器|\n|var|通用的属性类型|\n### QML模块提供的部分基本类型\n|类型|含义|\n|:---:|:---|\n|color|颜色类型值|\n|date|时间类型值|\n|font|字体类型值|\n|point|值带有x和y属性|\n|rect|值与x, y，宽度和高度属性|\n|size|值，该值具有宽度和高度属性|\n## 基本类型变量的动态绑定\n```QML\nWindow {\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n    Item {\n        anchors.fill: parent\n        id:root\n\n        property int number: parent.width  //定义变量等与窗口宽度\n        onNumberChanged:{                  //窗口变化,变量改变,触发槽函数\n            console.log('number',number)\n        }\n    }\n}\n```\n## 别名\n```QML\nWindow {\n    id : window\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n    Item {\n        anchors.fill: parent\n        id:root\n\n        property alias windowWidth: window.width  //使用别名windowWidth代替window.width\n\n        Component.onCompleted: {\n            windowWidth=100       //使用windowWidth可以控制窗口宽度\n        }\n    }\n}\n```","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(三)","url":"/2022/07/21/QML/QML学习笔记(三)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## QML的布局\n　　元素是以其**父对象**的左上角为基点,分别向左和向下进行延伸,可使用 `x:` 及 `y:` 进行位置的定义  \n　　`Z: ` 是对堆叠顺序进行定义,数字越大越靠顶部\n```QML\nWindow {\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n    Rectangle {             //定义一个矩形\n        id: rect0           //定义ID\n        x: 50               //定义x位置,相对于Window\n        y: 30               //定义x位置,相对于Window\n        width:100           //定义宽度\n        height: 100         //定义高度\n        border.width: 2     //定义边框宽度\n\n        Rectangle{          //定义一个矩形\n            id:rect1        //定义ID\n            x: 0            //定义x位置,相对于rect0\n            y: 0            //定义y位置,相对于rect0\n            z: 1            //定义堆叠顺序\n            width: 40\n            height: 40\n            color: \"red\"    //定义颜色\n                 }\n        Rectangle{          //定义一个矩形\n            id:rect2        //定义ID\n            x: 20           //定义x位置,相对于rect0\n            y: 20           //定义x位置,相对于rect0\n            z: 0            //定义堆叠顺序\n            width: 40\n            height: 40\n            color: \"green\"  //定义颜色\n                }\n             }\n}\n```\n![QML的布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/QML的布局.png)\n## 动态表达式绑定\n　　当`B`对象属性调用了`A`对象的属性，那么当`A`的属性变化时，`B`的属性会自动随之变化\n```QML\nRectangle{\n    id:rect1\n    x: 0\n    y: 0\n    width: 40\n    height: 40\n    color: \"red\"\n        }\nRectangle{\n    id:rect2\n    x: rect1.x              //采用rect1的x值\n    y: rect1.y+rect1.height //紧贴rect1的下部\n    width: 40\n    height: 40\n    color: \"green\"\n}\n//鼠标区域\nMouseArea{\n    anchors.fill: rect1 //鼠标锚点\n    drag.target: rect1  //rect1跟随鼠标进行更新\n}\n```\n　　当鼠标移动`rect1`时,`rect2`会自动跟随`rect1`进行移动\n![动态表达式绑定](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/动态表达式绑定.png)\n## 锚点布局\n　　可视组件必须有`宽度` `高度` `x` `y`的值  \n　　如不设定`x` `y`的值,默认为`0`\n```QML\nRectangle{          //没设定x,y和锚点,默认在0,0位置\n    id:rect1\n    width: 40\n    height: 70\n    color: \"red\"\n        }\nRectangle{\n    id:rect2\n    width: 60\n    height: 40\n    color: \"green\"\n    //设置rect2的垂直中心锚点与rect1的垂直中心锚点对齐\n    anchors.verticalCenter: rect1.verticalCenter\n    anchors.left: rect1.right   //设置rect2的左边锚点与rect1的右边锚点对齐\n    anchors.leftMargin: 5       //设置rect2的左外边距5px\n        }\n\nItem {      //不可视元素,不设置默认也会自带一个\n    anchors.fill: parent //设置填充整个窗口\n\n    Rectangle{\n        id: rect3\n        width: 30\n        height: 30\n        color: \"blue\"\n        anchors.right: parent.right//设置rect3的右边锚点与窗口右边锚点对齐\n        anchors.top: parent.top//设置rect3的顶部锚点与窗口顶部锚点对齐\n    }\n}\n```\n![锚点布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/锚点布局.png)\n## 使用锚点代替宽、高设置\n```QML\nItem {\n      anchors.fill: parent\n\n      Rectangle{          //没设定x,y和锚点,默认在0,0位置\n          id:rect1\n          width: parent.width/3\n          height: parent.height\n          color: \"red\"\n             }\n      Rectangle{\n          id:rect2\n          width: parent.width/3\n          height: parent.height\n          color: \"green\"\n          anchors.left: rect1.right\n                }\n      Rectangle{\n          id: rect3\n          color: \"blue\"\n          anchors.right: parent.right //设置rect3的右边锚点与窗口右边锚点对齐\n          anchors.left: rect2.right   //设置rect3的顶部锚点与窗口顶部锚点对齐\n          anchors.top: parent.top     //设置rect3的顶部锚点与rect2顶部锚点对齐\n          anchors.bottom: parent.bottom//设置rect3的底部锚点与窗口底部锚点对齐\n\n              }\n    }\n```\n![锚点代替宽高](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/锚点代替宽高.png)\n## 行、列布局\n　　\n```QML\nItem {\n            anchors.fill: parent\n\n            ColumnLayout{           //列布局\n                id: layout1\n\n                RadioButton{\n                    checked: true\n                    text: '火锅'\n                }\n                RadioButton{\n                    text: '水饺'\n                }\n                RadioButton{\n                    text: '混沌'\n                }\n            }\n            RowLayout{              //行布局\n                id: layout2\n                anchors.left: layout1.right\n                anchors.leftMargin: 30\n                \n                RadioButton{\n                    checked: true\n                    text: '火锅'\n                }\n                RadioButton{\n                    text: '水饺'\n                }\n                RadioButton{\n                    text: '混沌'\n                }\n            }\n        }\n```\n![行、列布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/行、列布局.png)\n## FLOW流式布局\n　　将元素按照顺序依次排列，默认从左向右，元素宽度超过FLOW宽度后，自动向下排列  \n　　可通过｀flow: Flow.TopToBottom｀改变为从上向下\n```QML\nItem {\n        anchors.fill: parent\n        id:root\n\n        Flow {\n            id:flow1\n            anchors.left: parent.left\n            anchors.right: parent.right\n\n            Rectangle {\n                id:rect1\n                width:root.width/2\n                height:100\n                color: 'red'\n            }\n            Rectangle {\n                id:rect2\n                width:root.width/2\n                height:100\n                color: 'green'\n            }\n            Rectangle {\n                id:rect3\n                width:root.width/2\n                height:100\n                color: 'blue'\n            }\n        }\n        Flow {\n            anchors.left: parent.left\n            anchors.right: parent.right\n            anchors.top: flow1.bottom\n            flow: Flow.TopToBottom\n            \n            Rectangle {\n                id:rect4\n                width:root.width/2\n                height:100\n                color: 'red'\n            }\n            Rectangle {\n                id:rect5\n                width:root.width/2\n                height:100\n                color: 'green'\n            }\n        }\n    }\n```\n![flow流式布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/流式布局.png)\n## 网格布局\n　　将元素按照网格方式排列,默认从左向右依次排列,超过设置`列数`后自动向下排列\n```QML\nItem {\n        anchors.fill: parent\n        id:root\n\n        Grid {\n            columns: 3      //设置3列\n            spacing: 2      //设置每个元素之间的间距\n            Rectangle { color: \"red\"; width: 50; height: 50 }\n            Rectangle { color: \"green\"; width: 20; height: 50 }\n            Rectangle { color: \"blue\"; width: 50; height: 20 }\n            Rectangle { color: \"cyan\"; width: 50; height: 50 }\n            Rectangle { color: \"magenta\"; width: 10; height: 10 }\n        }\n    }\n```\n![Grid网格布局](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Grid网格布局.png)","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(二)","url":"/2022/07/21/QML/QML学习笔记(二)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n## QML的信号与槽\n　　以Button为例,其信号函数在其父类中定义  \n![Button的信号函数](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Button的信号函数.png)\n　　槽函数的格式为，信号函数前加`on`且第一个字母大写,例:`clicked()`的槽函数为`onClicked:{  }`\n```QML\nimport QtQuick 2.14\nimport QtQuick.Window 2.14\nimport QtQuick.Controls\nimport QtQuick.Layouts\n\nWindow {\n    width: 300\n    height: 300\n    visible: true\n    title: qsTr(\"Hello World\")\n\n        Button {                    //定义一个按钮\n            id: btn1                //按钮的ID\n            width: 60               //按钮的宽度\n            height: 30              //按钮的高度\n            text: \"Ok\"\n            //clicked()信号的槽函数\n            onClicked: {            //按钮按下触发的槽函数\n                console.log('btn click')//打印信息\n            }\n        }\n}\n```\n![Button的信号与槽](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Button的信号与槽.png)\n## 控件的属性\n　　以`Button`为例,其属性函数在其父类中定义  \n![Button的属性函数](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Button的属性函数.png)\n　　基本上每一个属性函数都有一个槽函数与之对应的变化的信号,例:`text`属性的变化信号为`textChanged`,对应的槽函数为`onTextChanged:{  }`  \n　　但是Qt文档里并没有提到这一点\n```QML\nonTextChanged: {                            //当text被改变时触发的槽函数\n                console.log('btn text',text)//打印被改变后的文字\n            }\n\n            //clicked()信号的槽函数\n            onClicked: {\n                console.log('btn click')\n                text = 'change'             //将text变为'change'\n            }\n```\n![Button属性的槽函数](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/Button属性的槽函数.png)\n## 只读属性\n　　在属性中存在一种只读属性`only-read`,这种属性只能读取不能更改  \n　　例:`pressed:bool`，该属性保存按钮是否被物理按下。按钮可以通过触摸或按键事件来按下\n","tags":["Qt","QML","笔记"],"categories":["Qt"]},{"title":"QML学习笔记(一)","url":"/2022/07/21/QML/QML学习笔记(一)/","content":"\n{% note blue 'fas fa-bullhorn' %}\n\n本篇文章是对来自🤝BiliBili-**清晨与猫鱼**的QML教程的学习笔记，原视频链接👇\nhttps://www.bilibili.com/video/BV1Ay4y1W7xd?spm_id_from=..search-card.all.click&vd_source=4079f59f2068471b4d379822052e0270\n\n{% endnote %}\n\n---\n\n ## 创建一个QML工程\n\n　　创建QML工程时，选择创建Qt Quick项目\n\n![　](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/image-20220721131856526.png \"创建工程界面\")\n\n## 可视与不可视元素\n\n　　使用控件前需要导入对应的模块，例如：需要使用 Controls 控件在手册内寻找其对应模块，并引入模块\n\n![引入模块](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/image-20220721142837460.png)\n\n![手册中控件对应的模块](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/image-20220721143204201.png)\n　　可视元素为可以看到的元素，如：Button、Label  \n　　不可视元素为不可以看到的元素，如：Layout、RowLayout\n```QML\n  RowLayout {                           //不可视元素,竖排列\n        Button {                        //定义一个按钮\n            text: \"Ok\"                  //定义按钮的文字\n            onClicked: model.submit()   //定义按钮点击后触发效果\n        }\n        Button {                        //定义一个按钮\n            text: \"Cancel\"              //定义按钮的文字\n            onClicked: model.revert()   //定义按钮点击后触发效果\n        }\n    }\n    ColumnLayout{                       //不可视元素,横排列\n         x: 150                         //设置横排列的坐标\n         \n         Button {\n            text: \"Ok\"\n            onClicked: model.submit()\n        }\n         Button {\n            text: \"Cancel\"\n            onClicked: model.revert()\n        }\n    }\n```\n![可视与不可视元素](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/元素可视与不可视.png)\n## 子元素列表\n```QML\nItem {\n    anchors.fill: parent\n    id:root\n\n   Column {\n       id:cloumn\n\n       Rectangle{\n           width: 30\n           height: 30\n           color: \"red\"\n           property string name: 'rect1'\n       }\n       Rectangle{\n           width: 30\n           height: 30\n           color: \"blue\"\n           property string name: 'rect2'\n\n           Label{               //此项不属于column的子元素\n               text: 'label'\n           }\n       }\n       Component.onCompleted: {\n           console.log(cloumn.children.length)//取cloumn下的子元素个数\n           for(let i=0;i<cloumn.children.length;i++)    \n           {\n               console.log(cloumn.children[i].name)//遍历cloumn下的子元素的name项\n               console.log(cloumn.children[i].color)//遍历cloumn下的子元素的color项\n           }\n       }\n   }\n}\n```\n![子元素列表](https://picgobed.oss-cn-hangzhou.aliyuncs.com/image/子元素列表.png)","tags":["Qt","QML","笔记"],"categories":["Qt"]}]